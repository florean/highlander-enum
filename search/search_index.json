{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83d\udde1\ufe0f Highlander Enum Documentation","text":"<p>\"There can be only one!\" - A Python library for mutually exclusive flag enums with smart conflict resolution.</p> <p>Highlander Enum provides <code>ExFlag</code> and <code>OptionsFlag</code> - specialized variations of Python's <code>IntFlag</code> enum designed for scenarios where certain flags must be mutually exclusive. Think command-line options where <code>--verbose</code> and <code>--quiet</code> can't both be active, or configuration settings where only one mode can be selected at a time.</p>"},{"location":"#key-features","title":"\u2728 Key Features","text":"<ul> <li>\ud83d\udeab Mutually Exclusive Flags: Define groups where only one flag can be active</li> <li>\ud83d\udd00 Smart Conflict Resolution: Choose how conflicts are handled (RHS wins, LHS wins, or strict mode)</li> <li>\ud83c\udfc3 Performance Optimized: Uses bitmasks for fast conflict detection during bitwise operations</li> <li>\ud83d\udccb Command-Line Ready: <code>OptionsFlag</code> includes aliases and help text for CLI tools</li> <li>\ud83c\udfaf Type Safe: Full type hints and comprehensive test coverage (100%)</li> <li>\ud83d\udc0d Modern Python: Supports Python 3.11, 3.12, and 3.13</li> </ul>"},{"location":"#quick-example","title":"\ud83d\ude80 Quick Example","text":"<pre><code>from highlander import ExFlag\n\nclass NetworkMode(ExFlag):\n    # Basic flags that can be combined\n    IPV4 = 1\n    IPV6 = 2\n    ENCRYPTION = 4\n\n    # Mutually exclusive verbosity levels\n    QUIET = 16\n    VERBOSE = 32\n    DEBUG = 64, (QUIET, VERBOSE)  # Can't be combined with QUIET or VERBOSE\n\n# RHS (right-hand side) wins by default\nmode = NetworkMode.QUIET | NetworkMode.VERBOSE\nprint(mode)  # NetworkMode.VERBOSE (VERBOSE wins)\n\n# Non-conflicting flags combine normally\nmode = NetworkMode.IPV4 | NetworkMode.ENCRYPTION | NetworkMode.VERBOSE\nprint(mode)  # NetworkMode.ENCRYPTION|IPV4|VERBOSE\n</code></pre>"},{"location":"#documentation-sections","title":"\ud83d\udcda Documentation Sections","text":""},{"location":"#getting-started","title":"Getting Started","text":"<p>Learn how to install and get up and running with Highlander Enum in minutes.</p>"},{"location":"#user-guide","title":"User Guide","text":"<p>Comprehensive guide covering all features, conflict resolution strategies, and advanced usage patterns.</p>"},{"location":"#examples","title":"Examples","text":"<p>Real-world examples including command-line tools, game configurations, and file processors.</p>"},{"location":"#api-reference","title":"API Reference","text":"<p>Complete API documentation with detailed method signatures and descriptions.</p>"},{"location":"#use-cases","title":"\ud83c\udfaf Use Cases","text":"<p>Highlander Enum is perfect for scenarios where you need mutually exclusive flags:</p> <ul> <li>Command-Line Tools: <code>--verbose</code> vs <code>--quiet</code> options</li> <li>Configuration Settings: Quality levels like <code>LOW</code>, <code>MEDIUM</code>, <code>HIGH</code></li> <li>Game Settings: Graphics modes, difficulty levels, UI themes</li> <li>Network Protocols: Connection types, security levels</li> <li>File Processing: Compression levels, output formats</li> </ul>"},{"location":"#core-classes","title":"\ud83d\udd27 Core Classes","text":""},{"location":"#exflag","title":"<code>ExFlag</code>","text":"<p>The main class providing mutually exclusive flag behavior with configurable conflict resolution.</p> <pre><code>from highlander import ExFlag\n\nclass MyFlag(ExFlag, conflict=\"rhs\"):  # RHS, LHS, or STRICT\n    A = 1\n    B = 2, (A,)  # B conflicts with A\n    C = 4\n</code></pre>"},{"location":"#optionsflag","title":"<code>OptionsFlag</code>","text":"<p>Specialized for command-line options with aliases and help text.</p> <pre><code>from highlander import OptionsFlag\n\nclass MyOptions(OptionsFlag):\n    VERBOSE = 1, [\"v\", \"verbose\"], \"Enable verbose output\"\n    QUIET = 2, [\"q\", \"quiet\"], \"Suppress output\", (VERBOSE,)\n</code></pre>"},{"location":"#conflict-resolution","title":"\ud83c\udf9b\ufe0f Conflict Resolution","text":"<p>Choose how conflicts are resolved:</p> Strategy Behavior Example RHS (default) Right-hand side wins <code>A \\| B</code> \u2192 <code>B</code> LHS Left-hand side wins <code>A \\| B</code> \u2192 <code>A</code> STRICT Raises <code>ValueError</code> <code>A \\| B</code> \u2192 Exception"},{"location":"#installation","title":"\ud83d\ude80 Installation","text":"<pre><code>pip install highlander-enum\n</code></pre>"},{"location":"#links","title":"\ud83d\udd17 Links","text":"<ul> <li>Repository: https://github.com/florean/highlander-enum</li> <li>PyPI: https://pypi.org/project/highlander-enum/</li> <li>Issues: Report bugs or request features</li> <li>Discussions: Community discussions</li> </ul>"},{"location":"#license","title":"\ud83d\udcc4 License","text":"<p>This project is licensed under the Apache 2.0 License - see the LICENSE file for details.</p> <p>\"In the end, there can be only one... flag active in each exclusion group!\" \ud83d\udde1\ufe0f</p>"},{"location":"api-reference/","title":"API Reference","text":"<p>Complete API documentation for Highlander Enum classes and methods.</p>"},{"location":"api-reference/#core-imports","title":"Core Imports","text":"<pre><code>from highlander import ExFlag, OptionsFlag, EnumPlusType, RHS, LHS, STRICT\n</code></pre>"},{"location":"api-reference/#exflag-class","title":"ExFlag Class","text":"<p>The main class providing mutually exclusive flag behavior with configurable conflict resolution.</p>"},{"location":"api-reference/#class-definition","title":"Class Definition","text":"<pre><code>class ExFlag(IntFlag, metaclass=EnumPlusType)\n</code></pre> <p>Inherits from: <code>enum.IntFlag</code> Metaclass: <code>EnumPlusType</code></p>"},{"location":"api-reference/#class-parameters","title":"Class Parameters","text":"<p>When defining an ExFlag subclass, you can specify conflict resolution:</p> <pre><code>class MyFlag(ExFlag, conflict=\"rhs\"):  # or \"lhs\", \"strict\"\n    pass\n</code></pre> <p>Parameters:</p> <ul> <li><code>conflict</code> (str | ConflictResolution): Conflict resolution strategy</li> <li><code>\"rhs\"</code> or <code>ConflictResolution.RHS</code>: Right-hand side wins (default)</li> <li><code>\"lhs\"</code> or <code>ConflictResolution.LHS</code>: Left-hand side wins</li> <li><code>\"strict\"</code> or <code>ConflictResolution.STRICT</code>: Raise ValueError on conflicts</li> </ul>"},{"location":"api-reference/#class-attributes","title":"Class Attributes","text":""},{"location":"api-reference/#__exclusives__","title":"<code>__exclusives__</code>","text":"<pre><code>__exclusives__: ClassVar[defaultdict[int, int]]\n</code></pre> <p>Class variable storing bitmasks for mutually exclusive flags. Maps flag values to exclusion masks.</p> <p>Type: <code>defaultdict[int, int]</code> with default value <code>-1</code></p> <p>Example:</p> <pre><code>class MyFlag(ExFlag):\n    A = 1\n    B = 2, [A]\n\nprint(MyFlag.__exclusives__[1])  # Exclusion mask for A\nprint(MyFlag.__exclusives__[2])  # Exclusion mask for B\n</code></pre>"},{"location":"api-reference/#instance-creation","title":"Instance Creation","text":""},{"location":"api-reference/#__new__cls-value-args","title":"<code>__new__(cls, value, *args)</code>","text":"<p>Create new ExFlag enum members with optional exclusion definitions.</p> <p>Parameters:</p> <ul> <li><code>value</code> (int): The integer value for this flag</li> <li><code>*args</code> (Any): Optional arguments where the last argument can be a list of flags that should be mutually exclusive with this flag</li> </ul> <p>Returns: <code>Self</code> - A new ExFlag instance</p> <p>Example:</p> <pre><code>class MyFlag(ExFlag):\n    A = 1\n    B = 2\n    C = 4, [A, B]  # A, B, and C all conflict\n</code></pre>"},{"location":"api-reference/#__call__cls-value","title":"<code>__call__(cls, value)</code>","text":"<p>Create an ExFlag instance from an integer value, resolving conflicts.</p> <p>Parameters:</p> <ul> <li><code>value</code> (int): Integer value to convert to an ExFlag instance</li> </ul> <p>Returns: <code>Self</code> - An ExFlag instance with conflicts resolved</p> <p>Example:</p> <pre><code>class MyFlag(ExFlag):\n    A = 1\n    B = 2, [A]\n\nflag = MyFlag(3)  # 3 = A + B, conflicts resolved\nprint(flag)  # MyFlag.A (conflict resolved)\n</code></pre>"},{"location":"api-reference/#class-methods","title":"Class Methods","text":""},{"location":"api-reference/#add_mutual_exclusionsmutually_exclusive_values","title":"<code>add_mutual_exclusions(mutually_exclusive_values)</code>","text":"<pre><code>@classmethod\ndef add_mutual_exclusions(cls, mutually_exclusive_values: Sequence[IntFlag | int]) -&gt; None\n</code></pre> <p>Set multiple flags as mutually exclusive with each other. This is what is used when adding exclusions to a member definition.</p> <p>Parameters:</p> <ul> <li><code>mutually_exclusive_values</code> (Sequence[IntFlag | int]): Sequence of flag values that should be mutually exclusive with each other</li> </ul> <p>Example:</p> <pre><code>class MyFlag(ExFlag):\n    A = 1\n    B = 2\n    C = 4\n\nMyFlag.add_mutual_exclusions([MyFlag.A, MyFlag.B, MyFlag.C])  # Same as C = 4, [A, B]\n</code></pre>"},{"location":"api-reference/#instance-methods","title":"Instance Methods","text":""},{"location":"api-reference/#add_exclusionsexclusive_values","title":"<code>add_exclusions(*exclusive_values)</code>","text":"<pre><code>def add_exclusions(self, *exclusive_values: IntFlag | int) -&gt; None\n</code></pre> <p>Add flags that are mutually exclusive with this flag instance. This can be used to create more complicated relationships, such as one flag clearing a number of other ones. These should be added right after enum creation, although there are probably some creative ways to use them to dynamically adjust exclusions.</p> <p>Parameters:</p> <ul> <li><code>*exclusive_values</code> (IntFlag | int): Variable number of flags that should be mutually exclusive with this flag</li> </ul> <p>Example:</p> <pre><code>class MyFlag(ExFlag):\n    A = 1\n    B = 2\n    C = 4\n\nMyFlag.A.add_exclusions(MyFlag.B, MyFlag.C)\nMyFlag.B | MyFlag.C == MyFlag.C | MyFlag.B\nMyFlag.B | MyFlag.C | MyFlag.A == MyFlag.A\n</code></pre>"},{"location":"api-reference/#bitwise-operations","title":"Bitwise Operations","text":"<p>All bitwise operations support conflict resolution:</p>"},{"location":"api-reference/#__or__self-other","title":"<code>__or__(self, other)</code> (|)","text":"<p>Perform bitwise OR operation with conflict resolution.</p> <p>Parameters:</p> <ul> <li><code>other</code> (int): Integer value to combine with this flag</li> </ul> <p>Returns: <code>Self</code> - New ExFlag instance with the combined value after conflict resolution</p>"},{"location":"api-reference/#__xor__self-other","title":"<code>__xor__(self, other)</code> (^)","text":"<p>Perform bitwise XOR operation with conflict resolution.</p> <p>Parameters:</p> <ul> <li><code>other</code> (int): Integer value to XOR with this flag</li> </ul> <p>Returns: <code>Self</code> - New ExFlag instance with the XOR result after conflict resolution</p>"},{"location":"api-reference/#__and__self-other","title":"<code>__and__(self, other)</code> (&amp;)","text":"<p>Standard bitwise AND operation (no conflict resolution required).</p> <p>Parameters:</p> <ul> <li><code>other</code> (int): Integer value to AND with this flag</li> </ul> <p>Returns: <code>Self</code> - New ExFlag instance with the AND result</p>"},{"location":"api-reference/#reverse-operations","title":"Reverse Operations","text":""},{"location":"api-reference/#__ror__self-other-other-self","title":"<code>__ror__(self, other)</code> (other | self)","text":""},{"location":"api-reference/#__rxor__self-other-other-self","title":"<code>__rxor__(self, other)</code> (other ^ self)","text":""},{"location":"api-reference/#__rand__self-other-other-self","title":"<code>__rand__(self, other)</code> (other &amp; self)","text":"<p>Reverse bitwise operations that delegate to their forward counterparts.</p>"},{"location":"api-reference/#optionsflag-class","title":"OptionsFlag Class","text":"<p>Specialized ExFlag subclass for command-line options with aliases and help text.</p>"},{"location":"api-reference/#class-definition_1","title":"Class Definition","text":"<pre><code>class OptionsFlag(ExFlag)\n</code></pre> <p>Inherits from: <code>ExFlag</code></p>"},{"location":"api-reference/#instance-creation_1","title":"Instance Creation","text":""},{"location":"api-reference/#__new__cls-value-args_1","title":"<code>__new__(cls, value, *args)</code>","text":"<p>Create new OptionsFlag members with help text, aliases, and exclusions.</p> <p>Parameters:</p> <ul> <li><code>value</code> (int): Integer value for this flag</li> <li><code>*args</code> (Any): Variable arguments in one of these formats:</li> <li><code>(help_str,)</code> - Just help text</li> <li><code>([aliases], help_str)</code> - Aliases list and help text</li> <li><code>([aliases], help_str, (exclusions,))</code> - Full specification</li> <li><code>(help_str, (exclusions,))</code> - Help text and exclusions</li> </ul> <p>Returns: <code>Self</code> - New OptionsFlag instance</p> <p>Raises:</p> <ul> <li><code>TypeError</code>: If no help string is provided or too many arguments are given</li> </ul> <p>Examples:</p> <pre><code>class MyOptions(OptionsFlag):\n    # Different tuple formats:\n    SIMPLE = 1, \"Just help text\"\n    WITH_ALIASES = 2, [\"a\", \"alias\"], \"Help with aliases\"\n    FULL_SPEC = 4, [\"f\"], \"Full spec\", (WITH_ALIASES,)\n    HELP_EXCLUSIONS = 8, \"Help and exclusions\", (SIMPLE,)\n</code></pre>"},{"location":"api-reference/#properties","title":"Properties","text":""},{"location":"api-reference/#help","title":"<code>help</code>","text":"<pre><code>@property\ndef help(self) -&gt; str\n</code></pre> <p>Get the help text for this flag.</p> <p>Returns: <code>str</code> - The help text string provided during flag definition, or empty string if no help text was provided</p> <p>Example:</p> <pre><code>class MyOptions(OptionsFlag):\n    VERBOSE = 1, \"Enable verbose output\"\n\nprint(MyOptions.VERBOSE.help)  # \"Enable verbose output\"\n</code></pre>"},{"location":"api-reference/#aliases","title":"<code>aliases</code>","text":"<pre><code>@property\ndef aliases(self) -&gt; list[str]\n</code></pre> <p>Get the list of aliases for this flag.</p> <p>Returns: <code>list[str]</code> - List of string aliases that can be used to reference this flag</p> <p>Example:</p> <pre><code>class MyOptions(OptionsFlag):\n    VERBOSE = 1, [\"v\", \"verbose\"], \"Enable verbose output\"\n\nprint(MyOptions.VERBOSE.aliases)  # ['v', 'verbose']\n</code></pre>"},{"location":"api-reference/#conflict-resolution-enums","title":"Conflict Resolution Enums","text":""},{"location":"api-reference/#conflictresolution","title":"ConflictResolution","text":"<pre><code>class ConflictResolution(StrEnum)\n</code></pre> <p>Enumeration defining conflict resolution strategies.</p> <p>Values:</p> <ul> <li><code>RHS</code>: Right-hand side wins (default)</li> <li><code>LHS</code>: Left-hand side wins</li> <li><code>STRICT</code>: Raises ValueError on conflicts</li> </ul> <p>Example:</p> <pre><code>from highlander.type import ConflictResolution\n\nclass MyFlag(ExFlag, conflict=ConflictResolution.STRICT):\n    A = 1\n    B = 2, (A,)\n</code></pre>"},{"location":"api-reference/#convenience-imports","title":"Convenience Imports","text":"<p>For convenience, conflict resolution constants are available at package level:</p> <pre><code>from highlander import LHS, STRICT\n\n# Equivalent to:\nfrom highlander.type import ConflictResolution\nLHS = ConflictResolution.LHS\nSTRICT = ConflictResolution.STRICT\n</code></pre>"},{"location":"api-reference/#enumplustype-metaclass","title":"EnumPlusType Metaclass","text":""},{"location":"api-reference/#class-definition_2","title":"Class Definition","text":"<pre><code>class EnumPlusType(EnumType)\n</code></pre> <p>Metaclass for creating Enum subclasses with support for <code>super().__new__</code> for better subclassing, <code>__call__</code> to control member lookup, bitwise operation inheritance, control of subclases through <code>__init_subenum__</code>, and flexible conflict resolution policies.</p> <p>Inherits from: <code>enum.EnumType</code></p>"},{"location":"api-reference/#metaclass-parameters","title":"Metaclass Parameters","text":""},{"location":"api-reference/#__new__metacls-cls-bases-classdict-kwargs","title":"<code>__new__(metacls, cls, bases, classdict, **kwargs)</code>","text":"<p>Parameters:</p> <ul> <li><code>conflict_enum_cls</code> (type[Enum]): Enum class defining conflict resolution strategies (default: <code>ConflictResolution</code>)</li> <li><code>conflict</code> (Enum | str): The conflict resolution strategy to use (default: <code>ConflictResolution.RHS</code>)</li> <li><code>boundary</code> (Any): Boundary handling for flag values (passed to EnumType)</li> <li><code>_simple</code> (bool): Whether this is a simple enum (passed to EnumType)</li> <li><code>**kwds</code> (Any): Additional keyword arguments passed to parent metaclass</li> </ul> <p>Returns: <code>type</code> - The newly created enum class</p> <p>Raises:</p> <ul> <li><code>TypeError</code>: If the conflict resolution strategy is invalid or not implemented</li> </ul>"},{"location":"api-reference/#static-methods","title":"Static Methods","text":""},{"location":"api-reference/#restore_new_membersbases","title":"<code>restore_new_members(bases)</code>","text":"<pre><code>@staticmethod\ndef restore_new_members(bases: tuple[type, ...]) -&gt; dict[type, Callable[..., Any] | None]\n</code></pre> <p>Restore original <code>__new__</code> methods from <code>__new_member__</code> attributes.</p> <p>Parameters:</p> <ul> <li><code>bases</code> (tuple[type, ...]): Tuple of base classes to examine</li> </ul> <p>Returns: <code>dict[type, Callable[..., Any] | None]</code> - Dictionary mapping base classes to their original <code>__new__</code> methods</p>"},{"location":"api-reference/#restore_newsreplaced_new_methods","title":"<code>restore_news(replaced_new_methods)</code>","text":"<pre><code>@staticmethod\ndef restore_news(replaced_new_methods: dict[type, Callable[..., Any] | None]) -&gt; None\n</code></pre> <p>Restore previously saved <code>__new__</code> methods to their original classes.</p> <p>Parameters:</p> <ul> <li><code>replaced_new_methods</code> (dict[type, Callable[..., Any] | None]): Dictionary mapping classes to their original <code>__new__</code> methods</li> </ul>"},{"location":"api-reference/#utility-functions","title":"Utility Functions","text":""},{"location":"api-reference/#traverse_basesbases","title":"<code>traverse_bases(bases)</code>","text":"<pre><code>def traverse_bases(bases: tuple[type, ...]) -&gt; tuple[type, ...]\n</code></pre> <p>Traverse base classes to get an ordered list of the inheritance tree.</p> <p>Parameters:</p> <ul> <li><code>bases</code> (tuple[type, ...]): Tuple of base classes to traverse</li> </ul> <p>Returns: <code>tuple[type, ...]</code> - Ordered tuple of all classes in the inheritance hierarchy, excluding the built-in object class</p>"},{"location":"api-reference/#rebind_methodtarget_name-target_cls-src_method-src_clsnone","title":"<code>rebind_method(target_name, target_cls, src_method, src_cls=None)</code>","text":"<pre><code>def rebind_method(\n    target_name: str,\n    target_cls: type,\n    src_method: classmethod | staticmethod | Callable[..., Any] | str,\n    src_cls: type | None = None,\n) -&gt; None\n</code></pre> <p>Rebind a method from one class to another with a new name.</p> <p>Parameters:</p> <ul> <li><code>target_name</code> (str): The name to give the method in the target class</li> <li><code>target_cls</code> (type): The class to which the method should be bound</li> <li><code>src_method</code> (classmethod | staticmethod | Callable[..., Any] | str): The source method to copy</li> <li><code>src_cls</code> (type | None): The source class containing the method (required if src_method is a string)</li> </ul> <p>Raises:</p> <ul> <li><code>ValueError</code>: If src_method is a string but src_cls is not provided, if the method name is not found in src_cls, or if src_method is not a valid object</li> <li><code>TypeError</code>: If src_method is not callable or doesn't have the required function attributes</li> </ul>"},{"location":"api-reference/#type-annotations","title":"Type Annotations","text":"<p>All classes and methods include comprehensive type annotations for full IDE support and type checking with tools like mypy, pyright, and Pylance.</p>"},{"location":"api-reference/#common-type-patterns","title":"Common Type Patterns","text":"<pre><code>from typing import Any, ClassVar, Self, Sequence\nfrom enum import IntFlag\nfrom highlander import ExFlag\n\n# Flag instance type\nflag: ExFlag = MyFlag.A\n\n# Flag class type\nflag_cls: type[ExFlag] = MyFlag\n\n# Sequence of flags for exclusions\nexclusions: Sequence[IntFlag | int] = [MyFlag.A, MyFlag.B]\n\n# Exclusions mapping\nexclusives: defaultdict[int, int] = MyFlag.__exclusives__\n</code></pre>"},{"location":"api-reference/#exception-handling","title":"Exception Handling","text":""},{"location":"api-reference/#valueerror-in-strict-mode","title":"ValueError in STRICT Mode","text":"<p>When using STRICT conflict resolution, operations that would cause conflicts raise detailed <code>ValueError</code> exceptions:</p> <pre><code>from highlander import ExFlag, STRICT\n\nclass StrictFlag(ExFlag, conflict=STRICT):\n    A = 1\n    B = 2, (A,)\n\ntry:\n    result = StrictFlag.A | StrictFlag.B\nexcept ValueError as e:\n    print(f\"Conflict: {e}\")\n    # Output: \"Conflict: StrictFlag.B conflicts with StrictFlag.A\"\n</code></pre> <p>The error messages provide clear information about which specific flags conflict with each other.</p>"},{"location":"api-reference/#typeerror-in-class-creation","title":"TypeError in Class Creation","text":"<p>Invalid class definitions or parameters will raise <code>TypeError</code>:</p> <pre><code># Invalid conflict resolution\ntry:\n    class InvalidFlag(ExFlag, conflict=\"invalid\"):\n        A = 1\nexcept TypeError as e:\n    print(f\"Error: {e}\")\n    # Output: \"Error: Invalid conflict resolution: invalid\"\n\n# Missing help text in OptionsFlag\ntry:\n    class InvalidOptions(OptionsFlag):\n        NO_HELP = 1  # Missing help text\nexcept TypeError as e:\n    print(f\"Error: {e}\")\n    # Output: \"Error: A help string is required\"\n</code></pre> <p>For practical examples of these APIs in use, see the Examples section.</p>"},{"location":"contributing/","title":"Contributing to Highlander Enum","text":"<p>Thank you for your interest in contributing to Highlander Enum! This project maintains 100% test coverage because reliability is paramount for a library that works at such a fundamental level.</p>"},{"location":"contributing/#quick-start-for-contributors","title":"\ud83d\ude80 Quick Start for Contributors","text":""},{"location":"contributing/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.11 or higher</li> <li>uv (recommended) or pip</li> <li>Git</li> </ul>"},{"location":"contributing/#setting-up-the-development-environment","title":"Setting Up the Development Environment","text":"<ol> <li> <p>Fork and clone the repository: <code>bash    git clone https://github.com/your-username/highlander-enum.git    cd highlander-enum</code></p> </li> <li> <p>Set up the development environment: <code>bash    make install  # Sets up virtual environment and pre-commit hooks</code></p> </li> </ol> <p>Or manually with uv:    <code>bash    uv sync    uv run pre-commit install</code></p> <ol> <li>Verify your setup: <code>bash    make check  # Run all quality checks    make test   # Run tests with coverage</code></li> </ol>"},{"location":"contributing/#development-workflow","title":"\ud83e\uddea Development Workflow","text":""},{"location":"contributing/#running-tests","title":"Running Tests","text":"<pre><code># Run all tests with coverage\nmake test\n\n# Run tests for a specific file\nuv run python -m pytest tests/test_exflag.py -v\n\n# Run a specific test\nuv run python -m pytest tests/test_exflag.py::test_mutually_exclusive_flag_creation -v\n\n# Run tests across multiple Python versions\ntox\n</code></pre>"},{"location":"contributing/#code-quality-checks","title":"Code Quality Checks","text":"<pre><code># Run all quality checks (linting, type checking, dependency checking)\nmake check\n\n# Individual checks\nuv run pre-commit run -a    # Linting and formatting\nuv run ty check             # Type checking\nuv run deptry .             # Check for obsolete dependencies\n</code></pre>"},{"location":"contributing/#building-documentation","title":"Building Documentation","text":"<pre><code># Serve documentation locally\nmake docs\n\n# Test documentation build\nmake docs-test\n</code></pre>"},{"location":"contributing/#building-the-package","title":"Building the Package","text":"<pre><code># Build wheel file\nmake build\n</code></pre>"},{"location":"contributing/#code-style-and-standards","title":"\ud83d\udcdd Code Style and Standards","text":""},{"location":"contributing/#code-formatting","title":"Code Formatting","text":"<p>We use <code>ruff</code> for both linting and formatting:</p> <ul> <li>Line length: 100 characters</li> <li>Follow PEP 8 with project-specific rules in <code>pyproject.toml</code></li> <li>Pre-commit hooks automatically format code</li> </ul>"},{"location":"contributing/#type-hints","title":"Type Hints","text":"<ul> <li>All new code must include comprehensive type hints</li> <li>Use modern Python typing features (Python 3.11+)</li> <li>Import types from <code>typing</code> for compatibility</li> </ul> <pre><code>from typing import Any, ClassVar, Self, Sequence\nfrom collections.abc import Callable\n\ndef my_function(value: int, flags: Sequence[ExFlag]) -&gt; Self:\n    \"\"\"Example of proper type hints.\"\"\"\n    pass\n</code></pre>"},{"location":"contributing/#docstrings","title":"Docstrings","text":"<p>We use Google-style docstrings for all public APIs:</p> <pre><code>def add_exclusions(self, *exclusive_values: IntFlag | int) -&gt; None:\n    \"\"\"Add flags that are mutually exclusive with this flag instance.\n\n    This method allows runtime addition of exclusion relationships between\n    this flag and other flags. It creates bidirectional exclusions.\n\n    Args:\n        *exclusive_values: Variable number of flags (integers or IntFlag\n            instances) that should be mutually exclusive with this flag.\n\n    Example:\n        &gt;&gt;&gt; flag_a = MyFlag.A\n        &gt;&gt;&gt; flag_a.add_exclusions(MyFlag.B, MyFlag.C)\n    \"\"\"\n</code></pre>"},{"location":"contributing/#testing-requirements","title":"Testing Requirements","text":"<ul> <li>100% test coverage is mandatory</li> <li>Write tests for all new functionality</li> <li>Include edge cases and error conditions</li> <li>Test all conflict resolution strategies</li> <li>Use descriptive test names</li> </ul> <pre><code>def test_strict_conflict_resolution_with_multiple_groups():\n    \"\"\"Test that STRICT mode properly detects conflicts across multiple exclusion groups.\"\"\"\n    # Test implementation here\n</code></pre>"},{"location":"contributing/#types-of-contributions","title":"\ud83d\udd27 Types of Contributions","text":""},{"location":"contributing/#bug-reports","title":"\ud83d\udc1b Bug Reports","text":"<p>When reporting bugs, please include:</p> <ol> <li>Clear description of the problem</li> <li>Minimal reproduction case</li> <li>Expected vs actual behavior</li> <li>Python version and platform</li> <li>Highlander Enum version</li> </ol> <p>Template:</p> <pre><code>**Description**\nBrief description of the bug.\n\n**Reproduction**\n```python\nfrom highlander import ExFlag\n\nclass TestFlag(ExFlag):\n    A = 1\n    B = 2, [A]\n\n# This should work but doesn't\nresult = TestFlag.A | TestFlag.B\n</code></pre> <p>Expected: <code>TestFlag.B</code> Actual: <code>TestFlag.A</code></p> <p>Environment: - Python: 3.13.5 - Platform: macOS 14.1 - Highlander Enum: 0.9.1</p> <pre><code>\n### \ud83d\udca1 Feature Requests\n\nFor new features, please:\n\n1. **Search existing discussions** to avoid duplicates\n2. **Describe the use case** that motivates the feature\n3. **Provide examples** of how it would be used\n4. **Consider backwards compatibility**\n\n### \ud83d\udd28 Code Contributions\n\n#### Small Changes\n\nFor small changes (bug fixes, documentation improvements):\n\n1. Fork the repository\n2. Create a feature branch: `git checkout -b fix-issue-123`\n3. Make your changes\n4. Add tests if applicable\n5. Run quality checks: `make check`\n6. Commit with descriptive message\n7. Push and create a pull request\n\n#### Large Changes\n\nFor significant changes (new features, architectural changes):\n\n1. **Open a discussion first** to discuss the approach\n2. Get maintainer approval before starting work\n3. Consider breaking the work into smaller PRs\n4. Update documentation as needed\n\n#### Pull Request Process\n\n1. **Ensure all tests pass** and coverage remains 100%\n2. **Update documentation** for any API changes\n3. **Add changelog entry** if needed\n4. **Use descriptive commit messages**\n\n**Commit Message Format:**\n</code></pre> <p>type(scope): short description</p> <p>Longer explanation if needed.</p> <p>Fixes #123</p> <pre><code>\nTypes: `feat`, `fix`, `docs`, `test`, `refactor`, `perf`, `chore`\n\n## \ud83d\udcca Testing Guidelines\n\n### Test Organization\n\n</code></pre> <p>tests/ \u251c\u2500\u2500 test_exflag.py          # Tests for ExFlag class \u251c\u2500\u2500 test_optionsflag.py     # Tests for OptionsFlag class \u251c\u2500\u2500 test_enumplustype.py    # Tests for EnumPlusType metaclass \u2514\u2500\u2500 conftest.py             # Pytest configuration (if needed)</p> <pre><code>\n### Test Patterns\n\n#### Testing Conflict Resolution\n\n```python\ndef test_rhs_conflict_resolution():\n    \"\"\"Test RHS conflict resolution strategy.\"\"\"\n    class TestFlag(ExFlag):  # Default RHS\n        A = 1\n        B = 2, [A]\n\n    result = TestFlag.A | TestFlag.B\n    assert result == TestFlag.B  # RHS wins\n\ndef test_lhs_conflict_resolution():\n    \"\"\"Test LHS conflict resolution strategy.\"\"\"\n    class TestFlag(ExFlag, conflict=LHS):\n        A = 1\n        B = 2, [A]\n\n    result = TestFlag.A | TestFlag.B\n    assert result == TestFlag.A  # LHS wins\n\ndef test_strict_conflict_resolution():\n    \"\"\"Test STRICT conflict resolution raises ValueError.\"\"\"\n    class TestFlag(ExFlag, conflict=STRICT):\n        A = 1\n        B = 2, [A]\n\n    with pytest.raises(ValueError, match=\"conflicts with\"):\n        TestFlag.A | TestFlag.B\n</code></pre>"},{"location":"contributing/#testing-edge-cases","title":"Testing Edge Cases","text":"<pre><code>def test_empty_exclusions():\n    \"\"\"Test flags with empty exclusion lists combine normally.\"\"\"\n    class TestFlag(ExFlag):\n        A = 1, []  # Empty exclusions\n        B = 2\n\n    result = TestFlag.A | TestFlag.B\n    assert result.value == 3  # Should combine normally\n\ndef test_self_exclusion_error():\n    \"\"\"Test that flags cannot exclude themselves.\"\"\"\n    with pytest.raises(ValueError):\n        class InvalidFlag(ExFlag):\n            A = 1, [A]  # This should be invalid\n</code></pre>"},{"location":"contributing/#testing-optionsflag","title":"Testing OptionsFlag","text":"<pre><code>def test_options_flag_help_text():\n    \"\"\"Test that help text is properly stored and accessible.\"\"\"\n    class TestOptions(OptionsFlag):\n        VERBOSE = 1, \"Enable verbose output\"\n\n    assert TestOptions.VERBOSE.help == \"Enable verbose output\"\n\ndef test_options_flag_aliases():\n    \"\"\"Test that aliases are properly registered.\"\"\"\n    class TestOptions(OptionsFlag):\n        VERBOSE = 1, [\"v\", \"verbose\"], \"Enable verbose output\"\n\n    assert \"v\" in TestOptions.VERBOSE.aliases\n    assert \"verbose\" in TestOptions.VERBOSE.aliases\n    assert TestOptions._value2member_map_[\"v\"] == TestOptions.VERBOSE\n</code></pre>"},{"location":"contributing/#coverage-requirements","title":"Coverage Requirements","text":"<ul> <li>Line coverage: 100%</li> <li>Branch coverage: 100%</li> <li>All public methods must be tested</li> <li>All error conditions must be tested</li> </ul> <p>Check coverage with:</p> <pre><code>make test  # Includes coverage report\n</code></pre>"},{"location":"contributing/#documentation-guidelines","title":"\ud83d\udcda Documentation Guidelines","text":""},{"location":"contributing/#api-documentation","title":"API Documentation","text":"<ul> <li>All public APIs must have comprehensive docstrings</li> <li>Include examples in docstrings when helpful</li> <li>Document parameters, return values, and exceptions</li> <li>Use type hints consistently</li> </ul>"},{"location":"contributing/#user-documentation","title":"User Documentation","text":"<p>When adding features that affect users:</p> <ol> <li>Update the User Guide with new patterns</li> <li>Add examples to the Examples section</li> <li>Update API Reference if needed</li> <li>Add to Getting Started for basic features</li> </ol>"},{"location":"contributing/#documentation-testing","title":"Documentation Testing","text":"<p>Test that examples in documentation work:</p> <pre><code>make docs-test\n</code></pre>"},{"location":"contributing/#release-process","title":"\ud83d\udea6 Release Process","text":"<p>Maintainers handle releases, but contributors should:</p> <ol> <li>Update version numbers if instructed</li> <li>Add changelog entries for significant changes</li> <li>Ensure documentation is current</li> </ol>"},{"location":"contributing/#community-guidelines","title":"\ud83e\udd1d Community Guidelines","text":""},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":"<ul> <li>Be respectful and inclusive</li> <li>Focus on constructive feedback</li> <li>Help newcomers learn the codebase</li> <li>Celebrate contributions from all skill levels</li> </ul>"},{"location":"contributing/#communication","title":"Communication","text":"<ul> <li>GitHub Issues: Bug reports</li> <li>GitHub Discussions: Feature requests, Questions, ideas, general discussion</li> <li>Pull Request Reviews: Code feedback and suggestions</li> </ul>"},{"location":"contributing/#debugging-tips","title":"\ud83d\udd0d Debugging Tips","text":""},{"location":"contributing/#common-development-issues","title":"Common Development Issues","text":"<p>Tests failing locally but not in CI:</p> <pre><code># Ensure you have the same Python version as CI\npython --version\n\n# Run tests with the same settings as CI\nuv run python -m pytest tests/ -v\n</code></pre> <p>Type checking errors:</p> <pre><code># Run type checker locally\nuv run ty check\n\n# Check specific file\nuv run ty check highlander/enums.py\n</code></pre> <p>Coverage not 100%:</p> <pre><code># Run coverage with branch analysis\nuv run python -m pytest --cov=highlander --cov-branch --cov-report=html tests/\n\n# Open coverage report\nopen htmlcov/index.html\n</code></pre>"},{"location":"contributing/#debugging-conflict-resolution","title":"Debugging Conflict Resolution","text":"<pre><code># Check exclusion masks\nclass DebugFlag(ExFlag):\n    A = 1\n    B = 2, [A]\n\nprint(f\"A exclusions: {bin(DebugFlag.__exclusives__[1])}\")\nprint(f\"B exclusions: {bin(DebugFlag.__exclusives__[2])}\")\n\n# Test conflict resolution step by step\nflag_a = DebugFlag.A\nmask = flag_a._handle_conflict(DebugFlag.B)\nprint(f\"Conflict mask: {bin(mask)}\")\n</code></pre>"},{"location":"contributing/#good-first-issues","title":"\ud83c\udfaf Good First Issues","text":"<p>New contributors might want to start with:</p> <ul> <li>Documentation improvements</li> <li>Additional test cases</li> <li>Type hint improvements</li> <li>Example code additions</li> </ul> <p>Look for issues labeled <code>good-first-issue</code> or <code>help-wanted</code>.</p>"},{"location":"contributing/#getting-help","title":"\u2753 Getting Help","text":"<p>If you need help:</p> <ol> <li>Check existing documentation and examples</li> <li>Search closed issues for similar problems</li> <li>Ask in GitHub Discussions for general questions or feature requests</li> <li>Open an issue for specific bugs</li> </ol>"},{"location":"contributing/#recognition","title":"\ud83d\ude4f Recognition","text":"<p>All contributors are recognized in:</p> <ul> <li>Git commit history</li> <li>GitHub contributors page</li> <li>Release notes (for significant contributions)</li> </ul> <p>Thank you for helping make Highlander Enum better! \ud83d\udde1\ufe0f</p> <p>\"In the end, there can be only one... way to do things right: with tests!\" \ud83e\uddea</p>"},{"location":"examples/","title":"Examples","text":"<p>Real-world examples showing how to use Highlander Enum in various scenarios.</p>"},{"location":"examples/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Command-Line Tools</li> <li>Game Configuration</li> <li>Network Protocols</li> <li>File Processing</li> <li>Web Server Settings</li> <li>Advanced Patterns</li> </ol>"},{"location":"examples/#command-line-tools","title":"Command-Line Tools","text":""},{"location":"examples/#basic-cli-tool","title":"Basic CLI Tool","text":"<pre><code>import argparse\nfrom highlander import OptionsFlag\n\nclass CLIFlags(OptionsFlag):\n    # Verbosity levels (mutually exclusive)\n    QUIET = 1, [\"q\", \"quiet\"], \"Suppress all output\"\n    NORMAL = 2, [\"n\", \"normal\"], \"Normal output level\"\n    VERBOSE = 4, [\"v\", \"verbose\"], \"Verbose output\"\n    DEBUG = 8, [\"d\", \"debug\"], \"Debug output\", (QUIET, NORMAL, VERBOSE)\n\n    # Output formats (mutually exclusive)\n    TEXT = 16, [\"t\", \"text\"], \"Plain text output\"\n    JSON = 32, [\"j\", \"json\"], \"JSON formatted output\"\n    XML = 64, [\"x\", \"xml\"], \"XML formatted output\", (TEXT, JSON)\n\n    # Independent options\n    FORCE = 128, [\"f\", \"force\"], \"Force operation without confirmation\"\n    DRY_RUN = 256, [\"dry-run\"], \"Show what would be done without executing\"\n\ndef create_cli_parser():\n    \"\"\"Create argument parser from OptionsFlag definition.\"\"\"\n    parser = argparse.ArgumentParser(description=\"Example CLI tool\")\n\n    # Add arguments based on flag definitions\n    for flag in CLIFlags:\n        # Create argument name\n        arg_name = f\"--{flag.name.lower().replace('_', '-')}\"\n        aliases = [f\"--{alias}\" for alias in flag.aliases if len(alias) &gt; 1]\n        short_aliases = [f\"-{alias}\" for alias in flag.aliases if len(alias) == 1]\n\n        parser.add_argument(\n            arg_name, *(aliases + short_aliases),\n            action='store_true',\n            help=flag.help\n        )\n\n    return parser\n\ndef parse_cli_flags(args) -&gt; CLIFlags:\n    \"\"\"Convert parsed arguments to CLIFlags.\"\"\"\n    flags = CLIFlags(0)\n\n    if args.quiet: flags |= CLIFlags.QUIET\n    if args.normal: flags |= CLIFlags.NORMAL\n    if args.verbose: flags |= CLIFlags.VERBOSE\n    if args.debug: flags |= CLIFlags.DEBUG\n    if args.text: flags |= CLIFlags.TEXT\n    if args.json: flags |= CLIFlags.JSON\n    if args.xml: flags |= CLIFlags.XML\n    if args.force: flags |= CLIFlags.FORCE\n    if args.dry_run: flags |= CLIFlags.DRY_RUN\n\n    return flags\n\ndef main():\n    parser = create_cli_parser()\n    args = parser.parse_args()\n    flags = parse_cli_flags(args)\n\n    # Use the flags to control behavior\n    if flags &amp; CLIFlags.DEBUG:\n        print(\"Debug mode enabled\")\n        print(f\"Active flags: {flags}\")\n    elif flags &amp; CLIFlags.VERBOSE:\n        print(\"Verbose mode enabled\")\n    elif flags &amp; CLIFlags.QUIET:\n        pass  # Suppress output\n    else:\n        print(\"Normal operation\")\n\n    if flags &amp; CLIFlags.DRY_RUN:\n        print(\"DRY RUN: Would process files...\")\n    else:\n        print(\"Processing files...\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"examples/#advanced-cli-with-configuration","title":"Advanced CLI with Configuration","text":"<pre><code>import argparse\nimport json\nfrom enum import auto\nfrom pathlib import Path\n\nfrom highlander import OptionsFlag\n\nclass AppConfig(OptionsFlag):\n    # Log levels (mutually exclusive)\n    LOG_ERROR = auto(), [\"log-error\"], \"Log errors only\"\n    LOG_WARN = auto(), [\"log-warn\"], \"Log warnings and errors\"\n    LOG_INFO = auto(), [\"log-info\"], \"Log info, warnings, and errors\"\n    LOG_DEBUG = auto(), [\"log-debug\"], \"Log everything\", (LOG_ERROR, LOG_WARN, LOG_INFO)\n\n    # Performance modes (mutually exclusive)\n    FAST = auto(), [\"fast\"], \"Prioritize speed over accuracy\"\n    BALANCED = auto(), [\"balanced\"], \"Balance speed and accuracy\"\n    ACCURATE = auto(), [\"accurate\"], \"Prioritize accuracy over speed\", (FAST, BALANCED)\n\n    # Output options (mutually exclusive)\n    STDOUT = auto(), [\"stdout\"], \"Output to standard output\"\n    FILE = auto(), [\"file\"], \"Output to file\"\n    BOTH = auto(), [\"both\"], \"Output to both stdout and file\", (STDOUT, FILE)\n\n    # Feature flags (independent)\n    COLORS = auto(), [\"colors\"], \"Enable colored output\"\n    PROGRESS = auto(), [\"progress\"], \"Show progress bars\"\n    TIMESTAMPS = auto(), [\"timestamps\"], \"Include timestamps in output\"\n\nclass ConfigManager:\n    def __init__(self, config_file: Path = None):\n        self.config_file = config_file or Path(\"app.json\")\n        self.flags = AppConfig(0)\n\n    def load_from_file(self) -&gt; AppConfig:\n        \"\"\"Load configuration from JSON file.\"\"\"\n        if not self.config_file.exists():\n            return AppConfig(0)\n\n        with open(self.config_file) as f:\n            data = json.load(f)\n\n        flags = AppConfig(0)\n        for flag_name, enabled in data.get(\"flags\", {}).items():\n            if enabled and hasattr(AppConfig, flag_name):\n                flags |= getattr(AppConfig, flag_name)\n\n        return flags\n\n    def save_to_file(self, flags: AppConfig) -&gt; None:\n        \"\"\"Save configuration to JSON file.\"\"\"\n        data = {\n            \"flags\": {\n                flag.name: bool(flags &amp; flag)\n                for flag in AppConfig\n            }\n        }\n\n        with open(self.config_file, 'w') as f:\n            json.dump(data, f, indent=2)\n\n    def merge_cli_args(self, cli_flags: AppConfig) -&gt; AppConfig:\n        \"\"\"Merge CLI arguments with file configuration.\"\"\"\n        # CLI arguments override file configuration\n        return self.flags | cli_flags\n\n# Usage example\ndef main():\n    config_manager = ConfigManager()\n    file_config = config_manager.load_from_file()\n\n    # Parse CLI arguments (simplified)\n    cli_config = AppConfig.LOG_INFO | AppConfig.FAST | AppConfig.COLORS\n\n    # Merge configurations\n    final_config = config_manager.merge_cli_args(cli_config)\n\n    print(f\"Final configuration: {final_config}\")\n\n    # Save the final configuration\n    config_manager.save_to_file(final_config)\n</code></pre>"},{"location":"examples/#game-configuration","title":"Game Configuration","text":""},{"location":"examples/#graphics-settings-manager","title":"Graphics Settings Manager","text":"<pre><code>from enum import auto\n\nfrom highlander import ExFlag\n\nclass GraphicsSettings(ExFlag):\n    # Quality presets (mutually exclusive)\n    QUALITY_LOW = auto()\n    QUALITY_MEDIUM = auto()\n    QUALITY_HIGH = auto()\n    QUALITY_ULTRA = auto(), (QUALITY_LOW, QUALITY_MEDIUM, QUALITY_HIGH)\n\n    # Resolution scaling (mutually exclusive)\n    SCALE_50 = auto()\n    SCALE_75 = auto()\n    SCALE_100 = auto()\n    SCALE_125 = auto()\n    SCALE_150 = auto(), (SCALE_50, SCALE_75, SCALE_100, SCALE_125)\n\n    # Anti-aliasing (mutually exclusive)\n    AA_OFF = auto()\n    AA_FXAA = auto()\n    AA_MSAA_2X = auto()\n    AA_MSAA_4X = auto()\n    AA_MSAA_8X = auto(), (AA_OFF, AA_FXAA, AA_MSAA_2X, AA_MSAA_4X)\n\n    # Independent features\n    VSYNC = auto()\n    HDR = auto()\n    RAY_TRACING = auto()\n    MOTION_BLUR = auto()\n\nclass GameConfig:\n    def __init__(self):\n        # Default to medium quality, 100% scale, FXAA, no extras\n        self.graphics = (GraphicsSettings.QUALITY_MEDIUM |\n                        GraphicsSettings.SCALE_100 |\n                        GraphicsSettings.AA_FXAA)\n\n        self.performance_profile = \"balanced\"\n\n    def apply_preset(self, preset: str) -&gt; None:\n        \"\"\"Apply a graphics preset.\"\"\"\n        presets = {\n            \"low\": (GraphicsSettings.QUALITY_LOW |\n                   GraphicsSettings.SCALE_75 |\n                   GraphicsSettings.AA_OFF),\n\n            \"medium\": (GraphicsSettings.QUALITY_MEDIUM |\n                      GraphicsSettings.SCALE_100 |\n                      GraphicsSettings.AA_FXAA),\n\n            \"high\": (GraphicsSettings.QUALITY_HIGH |\n                    GraphicsSettings.SCALE_100 |\n                    GraphicsSettings.AA_MSAA_4X |\n                    GraphicsSettings.VSYNC),\n\n            \"ultra\": (GraphicsSettings.QUALITY_ULTRA |\n                     GraphicsSettings.SCALE_125 |\n                     GraphicsSettings.AA_MSAA_8X |\n                     GraphicsSettings.VSYNC |\n                     GraphicsSettings.HDR |\n                     GraphicsSettings.RAY_TRACING)\n        }\n\n        if preset in presets:\n            self.graphics = presets[preset]\n            self.performance_profile = preset\n\n    def toggle_feature(self, feature: GraphicsSettings) -&gt; None:\n        \"\"\"Toggle an independent feature on/off.\"\"\"\n        independent_features = {\n            GraphicsSettings.VSYNC,\n            GraphicsSettings.HDR,\n            GraphicsSettings.RAY_TRACING,\n            GraphicsSettings.MOTION_BLUR\n        }\n\n        if feature in independent_features:\n            self.graphics ^= feature\n\n    def get_performance_impact(self) -&gt; str:\n        \"\"\"Estimate performance impact of current settings.\"\"\"\n        impact_score = 0\n\n        # Quality impact\n        if self.graphics &amp; GraphicsSettings.QUALITY_ULTRA:\n            impact_score += 4\n        elif self.graphics &amp; GraphicsSettings.QUALITY_HIGH:\n            impact_score += 3\n        elif self.graphics &amp; GraphicsSettings.QUALITY_MEDIUM:\n            impact_score += 2\n        else:\n            impact_score += 1\n\n        # Anti-aliasing impact\n        if self.graphics &amp; GraphicsSettings.AA_MSAA_8X:\n            impact_score += 4\n        elif self.graphics &amp; GraphicsSettings.AA_MSAA_4X:\n            impact_score += 3\n        elif self.graphics &amp; GraphicsSettings.AA_MSAA_2X:\n            impact_score += 2\n        elif self.graphics &amp; GraphicsSettings.AA_FXAA:\n            impact_score += 1\n\n        # Feature impact\n        if self.graphics &amp; GraphicsSettings.RAY_TRACING:\n            impact_score += 3\n        if self.graphics &amp; GraphicsSettings.HDR:\n            impact_score += 1\n        if self.graphics &amp; GraphicsSettings.MOTION_BLUR:\n            impact_score += 1\n\n        if impact_score &lt;= 3:\n            return \"Low\"\n        elif impact_score &lt;= 6:\n            return \"Medium\"\n        elif impact_score &lt;= 9:\n            return \"High\"\n        else:\n            return \"Very High\"\n\n    def get_summary(self) -&gt; dict:\n        \"\"\"Get a summary of current settings.\"\"\"\n        settings = {}\n\n        # Determine quality level\n        for quality in [GraphicsSettings.QUALITY_LOW, GraphicsSettings.QUALITY_MEDIUM,\n                       GraphicsSettings.QUALITY_HIGH, GraphicsSettings.QUALITY_ULTRA]:\n            if self.graphics &amp; quality:\n                settings[\"quality\"] = quality.name.split(\"_\")[1].lower()\n                break\n\n        # Determine scale\n        for scale in [GraphicsSettings.SCALE_50, GraphicsSettings.SCALE_75,\n                     GraphicsSettings.SCALE_100, GraphicsSettings.SCALE_125,\n                     GraphicsSettings.SCALE_150]:\n            if self.graphics &amp; scale:\n                settings[\"scale\"] = scale.name.split(\"_\")[1] + \"%\"\n                break\n\n        # Determine anti-aliasing\n        for aa in [GraphicsSettings.AA_OFF, GraphicsSettings.AA_FXAA,\n                  GraphicsSettings.AA_MSAA_2X, GraphicsSettings.AA_MSAA_4X,\n                  GraphicsSettings.AA_MSAA_8X]:\n            if self.graphics &amp; aa:\n                settings[\"antialiasing\"] = aa.name.replace(\"AA_\", \"\").replace(\"_\", \" \")\n                break\n\n        # Check features\n        features = []\n        if self.graphics &amp; GraphicsSettings.VSYNC:\n            features.append(\"V-Sync\")\n        if self.graphics &amp; GraphicsSettings.HDR:\n            features.append(\"HDR\")\n        if self.graphics &amp; GraphicsSettings.RAY_TRACING:\n            features.append(\"Ray Tracing\")\n        if self.graphics &amp; GraphicsSettings.MOTION_BLUR:\n            features.append(\"Motion Blur\")\n\n        settings[\"features\"] = features\n        settings[\"performance_impact\"] = self.get_performance_impact()\n\n        return settings\n\n# Usage example\ndef main():\n    config = GameConfig()\n\n    print(\"Default settings:\")\n    print(config.get_summary())\n\n    print(\"\\nApplying ultra preset:\")\n    config.apply_preset(\"ultra\")\n    print(config.get_summary())\n\n    print(\"\\nToggling ray tracing off:\")\n    config.toggle_feature(GraphicsSettings.RAY_TRACING)\n    print(config.get_summary())\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"examples/#network-protocols","title":"Network Protocols","text":""},{"location":"examples/#connection-manager","title":"Connection Manager","text":"<pre><code>import socket\nimport ssl\nfrom enum import auto\n\nfrom highlander import ExFlag\n\nclass ConnectionFlags(ExFlag):\n    # Protocol versions (mutually exclusive)\n    IPV4 = auto()\n    IPV6 = auto()\n    DUAL_STACK = auto(), (IPV4, IPV6)\n\n    # Security levels (mutually exclusive)\n    PLAINTEXT = auto()\n    TLS_1_2 = auto()\n    TLS_1_3 = auto(), (PLAINTEXT, TLS_1_2)\n\n    # Connection modes (mutually exclusive)\n    BLOCKING = auto()\n    NON_BLOCKING = auto()\n    ASYNC = auto(), (BLOCKING, NON_BLOCKING)\n\n    # Features (independent)\n    COMPRESSION = auto()\n    KEEPALIVE = auto()\n    NAGLE_DISABLED = auto()\n    BUFFER_OPTIMIZATION = auto()\n\nclass NetworkConnection:\n    def __init__(self, host: str, port: int, flags: ConnectionFlags = None):\n        self.host = host\n        self.port = port\n        self.flags = flags or (ConnectionFlags.IPV4 |\n                              ConnectionFlags.TLS_1_3 |\n                              ConnectionFlags.NON_BLOCKING)\n        self.socket = None\n        self.ssl_context = None\n\n    def _create_socket(self) -&gt; socket.socket:\n        \"\"\"Create socket based on flags.\"\"\"\n        if self.flags &amp; ConnectionFlags.IPV6:\n            family = socket.AF_INET6\n        elif self.flags &amp; ConnectionFlags.DUAL_STACK:\n            family = socket.AF_INET6\n        else:\n            family = socket.AF_INET\n\n        sock = socket.socket(family, socket.SOCK_STREAM)\n\n        # Apply socket options based on flags\n        if self.flags &amp; ConnectionFlags.KEEPALIVE:\n            sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n\n        if self.flags &amp; ConnectionFlags.NAGLE_DISABLED:\n            sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n\n        if self.flags &amp; ConnectionFlags.NON_BLOCKING:\n            sock.setblocking(False)\n\n        return sock\n\n    def _create_ssl_context(self) -&gt; ssl.SSLContext:\n        \"\"\"Create SSL context based on flags.\"\"\"\n        if self.flags &amp; ConnectionFlags.PLAINTEXT:\n            return None\n\n        if self.flags &amp; ConnectionFlags.TLS_1_3:\n            context = ssl.create_default_context()\n            context.minimum_version = ssl.TLSVersion.TLSv1_3\n        elif self.flags &amp; ConnectionFlags.TLS_1_2:\n            context = ssl.create_default_context()\n            context.minimum_version = ssl.TLSVersion.TLSv1_2\n        else:\n            context = ssl.create_default_context()\n\n        return context\n\n    def connect(self) -&gt; bool:\n        \"\"\"Establish connection with configured flags.\"\"\"\n        try:\n            self.socket = self._create_socket()\n\n            # Connect to remote host\n            if self.flags &amp; ConnectionFlags.DUAL_STACK:\n                # Try IPv6 first, fallback to IPv4\n                try:\n                    self.socket.connect((self.host, self.port))\n                except (socket.gaierror, ConnectionRefusedError):\n                    self.socket.close()\n                    self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n                    self.socket.connect((self.host, self.port))\n            else:\n                self.socket.connect((self.host, self.port))\n\n            # Wrap with SSL if needed\n            if not (self.flags &amp; ConnectionFlags.PLAINTEXT):\n                self.ssl_context = self._create_ssl_context()\n                self.socket = self.ssl_context.wrap_socket(\n                    self.socket, server_hostname=self.host\n                )\n\n            return True\n\n        except Exception as e:\n            print(f\"Connection failed: {e}\")\n            if self.socket:\n                self.socket.close()\n            return False\n\n    def get_connection_info(self) -&gt; dict:\n        \"\"\"Get information about the current connection.\"\"\"\n        info = {\n            \"host\": self.host,\n            \"port\": self.port,\n            \"protocol\": \"IPv6\" if self.flags &amp; ConnectionFlags.IPV6 else \"IPv4\",\n            \"security\": \"TLS 1.3\" if self.flags &amp; ConnectionFlags.TLS_1_3 else\n                       \"TLS 1.2\" if self.flags &amp; ConnectionFlags.TLS_1_2 else \"Plaintext\",\n            \"mode\": \"Async\" if self.flags &amp; ConnectionFlags.ASYNC else\n                   \"Non-blocking\" if self.flags &amp; ConnectionFlags.NON_BLOCKING else \"Blocking\",\n            \"features\": []\n        }\n\n        if self.flags &amp; ConnectionFlags.COMPRESSION:\n            info[\"features\"].append(\"Compression\")\n        if self.flags &amp; ConnectionFlags.KEEPALIVE:\n            info[\"features\"].append(\"Keep-Alive\")\n        if self.flags &amp; ConnectionFlags.NAGLE_DISABLED:\n            info[\"features\"].append(\"Nagle Disabled\")\n        if self.flags &amp; ConnectionFlags.BUFFER_OPTIMIZATION:\n            info[\"features\"].append(\"Buffer Optimization\")\n\n        return info\n\n# Usage example\ndef main():\n    # Create secure connection with compression\n    flags = (ConnectionFlags.IPV4 |\n             ConnectionFlags.TLS_1_3 |\n             ConnectionFlags.NON_BLOCKING |\n             ConnectionFlags.COMPRESSION |\n             ConnectionFlags.KEEPALIVE)\n\n    conn = NetworkConnection(\"example.com\", 443, flags)\n\n    print(\"Connection configuration:\")\n    print(conn.get_connection_info())\n\n    # Connection will be resolved automatically - TLS_1_3 wins over conflicting options\n    print(f\"Active flags: {conn.flags}\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"examples/#file-processing","title":"File Processing","text":""},{"location":"examples/#file-processor-with-multiple-modes","title":"File Processor with Multiple Modes","text":"<pre><code>import gzip\nimport json\nimport os\nfrom pathlib import Path\nfrom typing import List, Dict, Any\n\nfrom highlander import OptionsFlag\n\nclass ProcessorOptions(OptionsFlag):\n    # Verbosity (mutually exclusive)\n    SILENT = 1, [\"s\", \"silent\"], \"No output except errors\"\n    NORMAL = 2, [\"n\", \"normal\"], \"Standard output\"\n    VERBOSE = 4, [\"v\", \"verbose\"], \"Detailed output\"\n    DEBUG = 8, [\"d\", \"debug\"], \"Debug output\", (SILENT, NORMAL, VERBOSE)\n\n    # Processing modes (mutually exclusive)\n    FAST = 16, [\"f\", \"fast\"], \"Fast processing (may skip some optimizations)\"\n    BALANCED = 32, [\"b\", \"balanced\"], \"Balanced speed/quality\"\n    THOROUGH = 64, [\"t\", \"thorough\"], \"Thorough processing\", (FAST, BALANCED)\n\n    # Output formats (mutually exclusive)\n    JSON_OUTPUT = 128, [\"json\"], \"Output in JSON format\"\n    XML_OUTPUT = 256, [\"xml\"], \"Output in XML format\"\n    CSV_OUTPUT = 512, [\"csv\"], \"Output in CSV format\"\n    PLAIN_OUTPUT = 1024, [\"plain\"], \"Plain text output\", (JSON_OUTPUT, XML_OUTPUT, CSV_OUTPUT)\n\n    # Features (independent)\n    BACKUP = 2048, [\"backup\"], \"Create backup files\"\n    COMPRESS = 4096, [\"compress\"], \"Compress output files\"\n    VALIDATE = 8192, [\"validate\"], \"Validate input files\"\n    PARALLEL = 16384, [\"parallel\"], \"Use parallel processing\"\n\nclass FileProcessor:\n    def __init__(self, options: ProcessorOptions = None):\n        self.options = options or (ProcessorOptions.NORMAL |\n                                  ProcessorOptions.BALANCED |\n                                  ProcessorOptions.JSON_OUTPUT)\n        self.processed_files: List[Path] = []\n        self.errors: List[str] = []\n        self.stats = {\n            \"files_processed\": 0,\n            \"files_skipped\": 0,\n            \"total_size\": 0,\n            \"processing_time\": 0\n        }\n\n    def _log(self, message: str, level: str = \"info\") -&gt; None:\n        \"\"\"Log message based on verbosity settings.\"\"\"\n        if self.options &amp; ProcessorOptions.SILENT and level != \"error\":\n            return\n\n        if level == \"debug\" and not (self.options &amp; ProcessorOptions.DEBUG):\n            return\n\n        if level == \"verbose\" and not (self.options &amp; (ProcessorOptions.VERBOSE | ProcessorOptions.DEBUG)):\n            return\n\n        prefix = {\n            \"error\": \"ERROR: \",\n            \"debug\": \"DEBUG: \",\n            \"verbose\": \"VERBOSE: \",\n            \"info\": \"\"\n        }.get(level, \"\")\n\n        print(f\"{prefix}{message}\")\n\n    def _create_backup(self, file_path: Path) -&gt; bool:\n        \"\"\"Create backup file if backup option is enabled.\"\"\"\n        if not (self.options &amp; ProcessorOptions.BACKUP):\n            return True\n\n        try:\n            backup_path = file_path.with_suffix(f\"{file_path.suffix}.bak\")\n            backup_path.write_bytes(file_path.read_bytes())\n            self._log(f\"Created backup: {backup_path}\", \"verbose\")\n            return True\n        except Exception as e:\n            self._log(f\"Failed to create backup for {file_path}: {e}\", \"error\")\n            return False\n\n    def _validate_file(self, file_path: Path) -&gt; bool:\n        \"\"\"Validate input file if validation is enabled.\"\"\"\n        if not (self.options &amp; ProcessorOptions.VALIDATE):\n            return True\n\n        try:\n            # Simple validation - check if file is readable and not empty\n            if not file_path.exists():\n                raise FileNotFoundError(f\"File not found: {file_path}\")\n\n            if file_path.stat().st_size == 0:\n                raise ValueError(f\"File is empty: {file_path}\")\n\n            # Try to read first few bytes\n            with open(file_path, 'rb') as f:\n                f.read(1024)\n\n            self._log(f\"Validated: {file_path}\", \"debug\")\n            return True\n\n        except Exception as e:\n            self._log(f\"Validation failed for {file_path}: {e}\", \"error\")\n            return False\n\n    def _process_file_content(self, content: str, file_path: Path) -&gt; Dict[str, Any]:\n        \"\"\"Process file content based on processing mode.\"\"\"\n        result = {\n            \"file\": str(file_path),\n            \"size\": len(content),\n            \"lines\": len(content.splitlines())\n        }\n\n        if self.options &amp; ProcessorOptions.FAST:\n            # Fast processing - minimal analysis\n            result[\"word_count\"] = len(content.split())\n\n        elif self.options &amp; ProcessorOptions.BALANCED:\n            # Balanced processing - moderate analysis\n            lines = content.splitlines()\n            result.update({\n                \"word_count\": len(content.split()),\n                \"non_empty_lines\": len([l for l in lines if l.strip()]),\n                \"average_line_length\": sum(len(l) for l in lines) / len(lines) if lines else 0\n            })\n\n        elif self.options &amp; ProcessorOptions.THOROUGH:\n            # Thorough processing - detailed analysis\n            lines = content.splitlines()\n            words = content.split()\n\n            result.update({\n                \"word_count\": len(words),\n                \"non_empty_lines\": len([l for l in lines if l.strip()]),\n                \"average_line_length\": sum(len(l) for l in lines) / len(lines) if lines else 0,\n                \"unique_words\": len(set(word.lower().strip('.,!?\";') for word in words)),\n                \"character_frequency\": dict(sorted(\n                    {char: content.lower().count(char) for char in set(content.lower())}.items(),\n                    key=lambda x: x[1], reverse=True\n                )[:10])  # Top 10 characters\n            })\n\n        return result\n\n    def _format_output(self, results: List[Dict[str, Any]]) -&gt; str:\n        \"\"\"Format results based on output format option.\"\"\"\n        if self.options &amp; ProcessorOptions.JSON_OUTPUT:\n            return json.dumps(results, indent=2)\n\n        elif self.options &amp; ProcessorOptions.XML_OUTPUT:\n            xml_lines = ['&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;', '&lt;results&gt;']\n            for result in results:\n                xml_lines.append('  &lt;file&gt;')\n                for key, value in result.items():\n                    if isinstance(value, dict):\n                        xml_lines.append(f'    &lt;{key}&gt;')\n                        for k, v in value.items():\n                            xml_lines.append(f'      &lt;{k}&gt;{v}&lt;/{k}&gt;')\n                        xml_lines.append(f'    &lt;/{key}&gt;')\n                    else:\n                        xml_lines.append(f'    &lt;{key}&gt;{value}&lt;/{key}&gt;')\n                xml_lines.append('  &lt;/file&gt;')\n            xml_lines.append('&lt;/results&gt;')\n            return '\\n'.join(xml_lines)\n\n        elif self.options &amp; ProcessorOptions.CSV_OUTPUT:\n            if not results:\n                return \"\"\n\n            # Get all possible keys\n            all_keys = set()\n            for result in results:\n                all_keys.update(result.keys())\n\n            # Filter out nested dictionaries for CSV\n            simple_keys = [k for k in all_keys if not isinstance(results[0].get(k), dict)]\n\n            csv_lines = [','.join(simple_keys)]\n            for result in results:\n                values = [str(result.get(k, '')) for k in simple_keys]\n                csv_lines.append(','.join(values))\n            return '\\n'.join(csv_lines)\n\n        else:  # PLAIN_OUTPUT\n            output_lines = []\n            for result in results:\n                output_lines.append(f\"File: {result['file']}\")\n                for key, value in result.items():\n                    if key != 'file' and not isinstance(value, dict):\n                        output_lines.append(f\"  {key}: {value}\")\n                output_lines.append(\"\")  # Empty line between files\n            return '\\n'.join(output_lines)\n\n    def _write_output(self, content: str, output_path: Path) -&gt; None:\n        \"\"\"Write output content, optionally compressed.\"\"\"\n        try:\n            if self.options &amp; ProcessorOptions.COMPRESS:\n                # Write compressed output\n                compressed_path = output_path.with_suffix(f\"{output_path.suffix}.gz\")\n                with gzip.open(compressed_path, 'wt', encoding='utf-8') as f:\n                    f.write(content)\n                self._log(f\"Compressed output written to: {compressed_path}\", \"verbose\")\n            else:\n                # Write regular output\n                output_path.write_text(content, encoding='utf-8')\n                self._log(f\"Output written to: {output_path}\", \"verbose\")\n\n        except Exception as e:\n            self._log(f\"Failed to write output: {e}\", \"error\")\n\n    def process_files(self, input_files: List[Path], output_path: Path = None) -&gt; Dict[str, Any]:\n        \"\"\"Process a list of input files.\"\"\"\n        import time\n\n        start_time = time.time()\n        results = []\n\n        self._log(f\"Processing {len(input_files)} files with options: {self.options}\")\n\n        for file_path in input_files:\n            try:\n                self._log(f\"Processing: {file_path}\", \"verbose\")\n\n                # Validate file if enabled\n                if not self._validate_file(file_path):\n                    self.stats[\"files_skipped\"] += 1\n                    continue\n\n                # Create backup if enabled\n                if not self._create_backup(file_path):\n                    self.stats[\"files_skipped\"] += 1\n                    continue\n\n                # Read and process file content\n                content = file_path.read_text(encoding='utf-8')\n                result = self._process_file_content(content, file_path)\n                results.append(result)\n\n                self.stats[\"files_processed\"] += 1\n                self.stats[\"total_size\"] += len(content)\n                self.processed_files.append(file_path)\n\n                self._log(f\"Completed: {file_path} ({len(content)} bytes)\", \"debug\")\n\n            except Exception as e:\n                error_msg = f\"Failed to process {file_path}: {e}\"\n                self._log(error_msg, \"error\")\n                self.errors.append(error_msg)\n                self.stats[\"files_skipped\"] += 1\n\n        # Write output if specified\n        if output_path and results:\n            formatted_output = self._format_output(results)\n            self._write_output(formatted_output, output_path)\n\n        self.stats[\"processing_time\"] = time.time() - start_time\n\n        # Print summary\n        self._log(f\"Processing complete:\", \"info\")\n        self._log(f\"  Files processed: {self.stats['files_processed']}\", \"info\")\n        self._log(f\"  Files skipped: {self.stats['files_skipped']}\", \"info\")\n        self._log(f\"  Total size: {self.stats['total_size']} bytes\", \"info\")\n        self._log(f\"  Processing time: {self.stats['processing_time']:.2f} seconds\", \"info\")\n\n        return {\n            \"results\": results,\n            \"stats\": self.stats,\n            \"errors\": self.errors\n        }\n\n# Usage example\ndef main():\n    # Create some test files\n    test_dir = Path(\"test_files\")\n    test_dir.mkdir(exist_ok=True)\n\n    test_files = []\n    for i in range(3):\n        test_file = test_dir / f\"test_{i}.txt\"\n        test_file.write_text(f\"This is test file {i}\\n\" * (10 + i * 5))\n        test_files.append(test_file)\n\n    # Configure processor with thorough processing, validation, backup, and JSON output\n    options = (ProcessorOptions.VERBOSE |\n              ProcessorOptions.THOROUGH |\n              ProcessorOptions.JSON_OUTPUT |\n              ProcessorOptions.VALIDATE |\n              ProcessorOptions.BACKUP |\n              ProcessorOptions.COMPRESS)\n\n    processor = FileProcessor(options)\n\n    # Process files\n    output_path = Path(\"results.json\")\n    result = processor.process_files(test_files, output_path)\n\n    print(f\"\\nProcessing results:\")\n    print(f\"Successfully processed: {len(result['results'])} files\")\n    print(f\"Errors: {len(result['errors'])}\")\n\n    # Clean up test files\n    import shutil\n    shutil.rmtree(test_dir)\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"examples/#web-server-settings","title":"Web Server Settings","text":""},{"location":"examples/#http-server-configuration","title":"HTTP Server Configuration","text":"<pre><code>from highlander import ExFlag\nfrom typing import Dict, Any\nimport ssl\n\nclass ServerFlags(ExFlag):\n    # HTTP versions (mutually exclusive)\n    HTTP_1_0 = 1\n    HTTP_1_1 = 2\n    HTTP_2 = 4\n    HTTP_3 = 8, (HTTP_1_0, HTTP_1_1, HTTP_2)\n\n    # SSL/TLS versions (mutually exclusive)\n    NO_SSL = 16\n    TLS_1_2 = 32\n    TLS_1_3 = 64, (NO_SSL, TLS_1_2)\n\n    # Compression (mutually exclusive)\n    NO_COMPRESSION = 128\n    GZIP = 256\n    BROTLI = 512, (NO_COMPRESSION, GZIP)\n\n    # Security features (independent)\n    HSTS = 1024\n    CSP = 2048\n    CORS = 4096\n    RATE_LIMITING = 8192\n\n    # Performance features (independent)\n    CACHING = 16384\n    CONNECTION_POOLING = 32768\n    LOAD_BALANCING = 65536\n\nclass WebServer:\n    def __init__(self, name: str, port: int, flags: ServerFlags = None):\n        self.name = name\n        self.port = port\n        self.flags = flags or (ServerFlags.HTTP_1_1 |\n                              ServerFlags.TLS_1_3 |\n                              ServerFlags.GZIP |\n                              ServerFlags.CACHING)\n\n    def get_configuration(self) -&gt; Dict[str, Any]:\n        \"\"\"Get server configuration based on flags.\"\"\"\n        config = {\n            \"server_name\": self.name,\n            \"port\": self.port,\n            \"protocols\": [],\n            \"security\": {},\n            \"compression\": \"none\",\n            \"features\": []\n        }\n\n        # Determine HTTP version\n        if self.flags &amp; ServerFlags.HTTP_3:\n            config[\"protocols\"] = [\"HTTP/3\", \"HTTP/2\", \"HTTP/1.1\"]\n        elif self.flags &amp; ServerFlags.HTTP_2:\n            config[\"protocols\"] = [\"HTTP/2\", \"HTTP/1.1\"]\n        elif self.flags &amp; ServerFlags.HTTP_1_1:\n            config[\"protocols\"] = [\"HTTP/1.1\"]\n        elif self.flags &amp; ServerFlags.HTTP_1_0:\n            config[\"protocols\"] = [\"HTTP/1.0\"]\n\n        # Determine SSL/TLS\n        if self.flags &amp; ServerFlags.TLS_1_3:\n            config[\"security\"][\"tls_version\"] = \"1.3\"\n            config[\"security\"][\"ssl_enabled\"] = True\n        elif self.flags &amp; ServerFlags.TLS_1_2:\n            config[\"security\"][\"tls_version\"] = \"1.2\"\n            config[\"security\"][\"ssl_enabled\"] = True\n        else:\n            config[\"security\"][\"ssl_enabled\"] = False\n\n        # Security features\n        if self.flags &amp; ServerFlags.HSTS:\n            config[\"security\"][\"hsts\"] = True\n        if self.flags &amp; ServerFlags.CSP:\n            config[\"security\"][\"csp\"] = True\n        if self.flags &amp; ServerFlags.CORS:\n            config[\"security\"][\"cors\"] = True\n        if self.flags &amp; ServerFlags.RATE_LIMITING:\n            config[\"security\"][\"rate_limiting\"] = True\n\n        # Compression\n        if self.flags &amp; ServerFlags.BROTLI:\n            config[\"compression\"] = \"brotli\"\n        elif self.flags &amp; ServerFlags.GZIP:\n            config[\"compression\"] = \"gzip\"\n\n        # Performance features\n        if self.flags &amp; ServerFlags.CACHING:\n            config[\"features\"].append(\"caching\")\n        if self.flags &amp; ServerFlags.CONNECTION_POOLING:\n            config[\"features\"].append(\"connection_pooling\")\n        if self.flags &amp; ServerFlags.LOAD_BALANCING:\n            config[\"features\"].append(\"load_balancing\")\n\n        return config\n\n    def generate_nginx_config(self) -&gt; str:\n        \"\"\"Generate nginx configuration based on flags.\"\"\"\n        config_lines = [\n            \"server {\",\n            f\"    listen {self.port};\",\n            f\"    server_name {self.name};\",\n            \"\"\n        ]\n\n        # SSL configuration\n        if self.flags &amp; (ServerFlags.TLS_1_2 | ServerFlags.TLS_1_3):\n            config_lines.extend([\n                f\"    listen {self.port} ssl;\",\n                \"    ssl_certificate /path/to/cert.pem;\",\n                \"    ssl_certificate_key /path/to/key.pem;\",\n            ])\n\n            if self.flags &amp; ServerFlags.TLS_1_3:\n                config_lines.append(\"    ssl_protocols TLSv1.3;\")\n            elif self.flags &amp; ServerFlags.TLS_1_2:\n                config_lines.append(\"    ssl_protocols TLSv1.2 TLSv1.3;\")\n\n        # HTTP version support\n        if self.flags &amp; ServerFlags.HTTP_2:\n            config_lines.append(\"    http2 on;\")\n\n        # Compression\n        if self.flags &amp; ServerFlags.GZIP:\n            config_lines.extend([\n                \"    gzip on;\",\n                \"    gzip_types text/plain application/json text/css;\",\n            ])\n        elif self.flags &amp; ServerFlags.BROTLI:\n            config_lines.extend([\n                \"    brotli on;\",\n                \"    brotli_types text/plain application/json text/css;\",\n            ])\n\n        # Security headers\n        if self.flags &amp; ServerFlags.HSTS:\n            config_lines.append(\"    add_header Strict-Transport-Security \\\"max-age=31536000\\\";\")\n\n        if self.flags &amp; ServerFlags.CSP:\n            config_lines.append(\"    add_header Content-Security-Policy \\\"default-src 'self'\\\";\")\n\n        if self.flags &amp; ServerFlags.CORS:\n            config_lines.append(\"    add_header Access-Control-Allow-Origin \\\"*\\\";\")\n\n        # Rate limiting\n        if self.flags &amp; ServerFlags.RATE_LIMITING:\n            config_lines.append(\"    limit_req zone=api burst=20 nodelay;\")\n\n        # Caching\n        if self.flags &amp; ServerFlags.CACHING:\n            config_lines.extend([\n                \"    location ~* \\\\.(jpg|jpeg|png|gif|ico|css|js)$ {\",\n                \"        expires 1y;\",\n                \"        add_header Cache-Control \\\"public\\\";\",\n                \"    }\",\n            ])\n\n        config_lines.append(\"}\")\n        return \"\\n\".join(config_lines)\n\n    def get_performance_score(self) -&gt; int:\n        \"\"\"Calculate performance score based on configuration.\"\"\"\n        score = 0\n\n        # HTTP version benefits\n        if self.flags &amp; ServerFlags.HTTP_3:\n            score += 40\n        elif self.flags &amp; ServerFlags.HTTP_2:\n            score += 30\n        elif self.flags &amp; ServerFlags.HTTP_1_1:\n            score += 20\n        else:\n            score += 10\n\n        # Compression benefits\n        if self.flags &amp; ServerFlags.BROTLI:\n            score += 25\n        elif self.flags &amp; ServerFlags.GZIP:\n            score += 15\n\n        # Caching benefit\n        if self.flags &amp; ServerFlags.CACHING:\n            score += 20\n\n        # Connection pooling benefit\n        if self.flags &amp; ServerFlags.CONNECTION_POOLING:\n            score += 10\n\n        # Load balancing benefit\n        if self.flags &amp; ServerFlags.LOAD_BALANCING:\n            score += 15\n\n        return min(score, 100)  # Cap at 100\n\n# Usage example\ndef main():\n    # Create a high-performance secure server\n    server = WebServer(\n        \"api.example.com\",\n        443,\n        ServerFlags.HTTP_2 |\n        ServerFlags.TLS_1_3 |\n        ServerFlags.BROTLI |\n        ServerFlags.HSTS |\n        ServerFlags.CSP |\n        ServerFlags.RATE_LIMITING |\n        ServerFlags.CACHING |\n        ServerFlags.CONNECTION_POOLING\n    )\n\n    print(\"Server Configuration:\")\n    config = server.get_configuration()\n    for key, value in config.items():\n        print(f\"  {key}: {value}\")\n\n    print(f\"\\nPerformance Score: {server.get_performance_score()}/100\")\n\n    print(f\"\\nNginx Configuration:\")\n    print(server.generate_nginx_config())\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"examples/#advanced-patterns","title":"Advanced Patterns","text":""},{"location":"examples/#state-machine-with-exclusions","title":"State Machine with Exclusions","text":"<pre><code>from typing import Set, Dict, Callable\n\nfrom highlander import ExFlag, STRICT\n\nclass WorkflowState(ExFlag, conflict=STRICT):\n    # Initial states (mutually exclusive)\n    CREATED = 1\n    INITIALIZED = 2, (CREATED,)\n\n    # Processing states (mutually exclusive with initial and final)\n    PROCESSING = 4\n    PAUSED = 8\n    RETRYING = 16, (CREATED, INITIALIZED, PROCESSING, PAUSED)\n\n    # Final states (mutually exclusive with all others)\n    COMPLETED = 32\n    FAILED = 64\n    CANCELLED = 128, (CREATED, INITIALIZED, PROCESSING, PAUSED, RETRYING, COMPLETED, FAILED)\nWorkflowState\n\nclass WorkflowStateMachine:\n    def __init__(self, workflow_id: str):\n        self.workflow_id = workflow_id\n        self.current_state = WorkflowState.CREATED\n        self.state_history: List[WorkflowState] = [self.current_state]\n\n        # Define valid transitions\n        self.valid_transitions: Dict[WorkflowState, Set[WorkflowState]] = {\n            WorkflowState.CREATED: {WorkflowState.INITIALIZED, WorkflowState.CANCELLED},\n            WorkflowState.INITIALIZED: {WorkflowState.PROCESSING, WorkflowState.CANCELLED},\n            WorkflowState.PROCESSING: {WorkflowState.COMPLETED, WorkflowState.FAILED,\n                                     WorkflowState.PAUSED, WorkflowState.CANCELLED},\n            WorkflowState.PAUSED: {WorkflowState.PROCESSING, WorkflowState.CANCELLED},\n            WorkflowState.RETRYING: {WorkflowState.PROCESSING, WorkflowState.FAILED,\n                                   WorkflowState.CANCELLED},\n            WorkflowState.COMPLETED: set(),  # Terminal state\n            WorkflowState.FAILED: {WorkflowState.RETRYING, WorkflowState.CANCELLED},\n            WorkflowState.CANCELLED: set()   # Terminal state\n        }\n\n        # State handlers\n        self.state_handlers: Dict[WorkflowState, Callable] = {\n            WorkflowState.INITIALIZED: self._on_initialized,\n            WorkflowState.PROCESSING: self._on_processing,\n            WorkflowState.PAUSED: self._on_paused,\n            WorkflowState.RETRYING: self._on_retrying,\n            WorkflowState.COMPLETED: self._on_completed,\n            WorkflowState.FAILED: self._on_failed,\n            WorkflowState.CANCELLED: self._on_cancelled\n        }\n\n    def transition_to(self, new_state: WorkflowState) -&gt; bool:\n        \"\"\"Attempt to transition to a new state.\"\"\"\n        try:\n            # Check if transition is valid\n            if new_state not in self.valid_transitions[self.current_state]:\n                raise ValueError(f\"Invalid transition from {self.current_state} to {new_state}\")\n\n            # Attempt the state change (will raise if exclusions conflict)\n            test_state = self.current_state | new_state\n\n            # If we get here, transition is valid\n            old_state = self.current_state\n            self.current_state = new_state\n            self.state_history.append(new_state)\n\n            print(f\"Workflow {self.workflow_id}: {old_state} \u2192 {new_state}\")\n\n            # Execute state handler\n            if new_state in self.state_handlers:\n                self.state_handlers[new_state]()\n\n            return True\n\n        except (ValueError, TypeError) as e:\n            print(f\"Transition failed: {e}\")\n            return False\n\n    def _on_initialized(self):\n        print(f\"  Workflow {self.workflow_id} initialized and ready for processing\")\n\n    def _on_processing(self):\n        print(f\"  Workflow {self.workflow_id} is now processing\")\n\n    def _on_paused(self):\n        print(f\"  Workflow {self.workflow_id} has been paused\")\n\n    def _on_retrying(self):\n        print(f\"  Workflow {self.workflow_id} is retrying after failure\")\n\n    def _on_completed(self):\n        print(f\"  Workflow {self.workflow_id} completed successfully\")\n\n    def _on_failed(self):\n        print(f\"  Workflow {self.workflow_id} failed\")\n\n    def _on_cancelled(self):\n        print(f\"  Workflow {self.workflow_id} was cancelled\")\n\n    def get_available_transitions(self) -&gt; Set[WorkflowState]:\n        \"\"\"Get states that can be transitioned to from current state.\"\"\"\n        return self.valid_transitions[self.current_state]\n\n    def is_terminal(self) -&gt; bool:\n        \"\"\"Check if current state is terminal.\"\"\"\n        return len(self.valid_transitions[self.current_state]) == 0\n\n    def get_state_summary(self) -&gt; Dict[str, Any]:\n        \"\"\"Get summary of current state machine.\"\"\"\n        return {\n            \"workflow_id\": self.workflow_id,\n            \"current_state\": self.current_state.name,\n            \"is_terminal\": self.is_terminal(),\n            \"available_transitions\": [state.name for state in self.get_available_transitions()],\n            \"state_history\": [state.name for state in self.state_history]\n        }\n\n# Usage example\ndef main():\n    # Create a workflow\n    workflow = WorkflowStateMachine(\"WF-001\")\n\n    print(\"Initial state:\")\n    print(workflow.get_state_summary())\n    print()\n\n    # Execute a typical workflow\n    transitions = [\n        WorkflowState.INITIALIZED,\n        WorkflowState.PROCESSING,\n        WorkflowState.PAUSED,\n        WorkflowState.PROCESSING,\n        WorkflowState.COMPLETED\n    ]\n\n    for next_state in transitions:\n        success = workflow.transition_to(next_state)\n        if not success:\n            print(\"Workflow execution stopped due to invalid transition\")\n            break\n        print(f\"Available next states: {[s.name for s in workflow.get_available_transitions()]}\")\n        print()\n\n    print(\"Final state:\")\n    print(workflow.get_state_summary())\n\n    # Demonstrate invalid transition attempt\n    print(\"\\nAttempting invalid transition from terminal state:\")\n    workflow.transition_to(WorkflowState.PROCESSING)\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>These examples demonstrate the power and flexibility of Highlander Enum across various domains. Each example shows different aspects:</p> <ol> <li>Mutual exclusion ensuring only one option from conflicting groups can be active</li> <li>Conflict resolution handling what happens when conflicts occur</li> <li>Rich metadata with <code>OptionsFlag</code> for building user interfaces</li> <li>Complex state management with multiple exclusion groups</li> <li>Integration patterns with existing libraries and frameworks</li> <li>Type safety and IDE support throughout</li> </ol> <p>The key takeaway is that Highlander Enum provides a robust foundation for managing complex flag relationships while maintaining clean, readable code.</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Welcome to Highlander Enum! This guide will get you up and running with mutually exclusive flag enums in just a few minutes.</p>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>Install Highlander Enum using pip:</p> <pre><code>pip install highlander-enum\n</code></pre>"},{"location":"getting-started/#requirements","title":"Requirements","text":"<ul> <li>Python 3.11 or higher</li> <li>No additional dependencies required</li> </ul>"},{"location":"getting-started/#your-first-highlander-enum","title":"Your First Highlander Enum","text":"<p>Let's start with a simple example. Imagine you're building a logging system where you want different verbosity levels, but only one can be active at a time:</p> <pre><code>from highlander import ExFlag\n\nclass LogLevel(ExFlag):\n    ERROR = 1\n    WARN = 2\n    INFO = 4\n    DEBUG = 8, (ERROR, WARN, INFO)  # Only one logging level can be set\n\n# When flags conflict, the right-hand side (RHS) wins by default\nlevel = LogLevel.ERROR | LogLevel.INFO\nprint(level)  # LogLevel.INFO (INFO wins over ERROR)\n\n# Non-conflicting flags still work normally\n# (In this case, all levels conflict, so you'll always get just one)\n</code></pre>"},{"location":"getting-started/#understanding-conflict-resolution","title":"Understanding Conflict Resolution","text":"<p>Highlander Enum offers three conflict resolution strategies:</p>"},{"location":"getting-started/#1-rhs-right-hand-side-default","title":"1. RHS (Right-Hand Side) - Default","text":"<p>The newest (right-most) value wins when conflicts occur:</p> <pre><code>from highlander import ExFlag\n\nclass Mode(ExFlag):\n    FAST = 1\n    SLOW = 2, (FAST,)  # SLOW conflicts with FAST\n\nresult = Mode.FAST | Mode.SLOW\nprint(result)  # Mode.SLOW (right side wins)\n</code></pre>"},{"location":"getting-started/#2-lhs-left-hand-side","title":"2. LHS (Left-Hand Side)","text":"<p>The existing (left-most) value wins when conflicts occur:</p> <pre><code>from highlander import ExFlag, LHS\n\nclass Mode(ExFlag, conflict=LHS):\n    FAST = 1\n    SLOW = 2, (FAST,)\n\nresult = Mode.FAST | Mode.SLOW\nprint(result)  # Mode.FAST (left side wins)\n</code></pre>"},{"location":"getting-started/#3-strict-mode","title":"3. STRICT Mode","text":"<p>Raises an exception when conflicts occur:</p> <pre><code>from highlander import ExFlag, STRICT\n\nclass Mode(ExFlag, conflict=STRICT):\n    FAST = 1\n    SLOW = 2, (FAST,)\n\ntry:\n    result = Mode.FAST | Mode.SLOW\nexcept ValueError as e:\n    print(f\"Conflict detected: {e}\")\n    # Output: Conflict detected: Mode.SLOW conflicts with Mode.FAST\n</code></pre>"},{"location":"getting-started/#working-with-multiple-groups","title":"Working with Multiple Groups","text":"<p>You can create multiple independent exclusion groups:</p> <pre><code>from highlander import ExFlag\n\nclass UISettings(ExFlag):\n    # Color theme group (mutually exclusive)\n    LIGHT_THEME = 1\n    DARK_THEME = 2\n    HIGH_CONTRAST = 4, (LIGHT_THEME, DARK_THEME)\n\n    # Font size group (mutually exclusive)\n    SMALL_FONT = 8\n    MEDIUM_FONT = 16\n    LARGE_FONT = 32, (SMALL_FONT, MEDIUM_FONT)\n\n    # Independent features (no conflicts)\n    ANIMATIONS = 64\n    SOUND_EFFECTS = 128\n\n# You can mix flags from different groups\nsettings = UISettings.DARK_THEME | UISettings.LARGE_FONT | UISettings.ANIMATIONS\nprint(settings)  # UISettings.ANIMATIONS|DARK_THEME|LARGE_FONT\n\n# Conflicts are resolved within groups\nsettings = UISettings.LIGHT_THEME | UISettings.DARK_THEME | UISettings.SMALL_FONT\nprint(settings)  # UISettings.DARK_THEME|SMALL_FONT (DARK_THEME wins)\n</code></pre>"},{"location":"getting-started/#command-line-options-with-optionsflag","title":"Command-Line Options with OptionsFlag","text":"<p>For command-line tools, use <code>OptionsFlag</code> which includes aliases and help text:</p> <pre><code>from highlander import OptionsFlag\n\nclass ServerOptions(OptionsFlag):\n    # Format: VALUE, [aliases], \"help text\", [exclusions]\n    VERBOSE = 1, [\"v\", \"verbose\"], \"Enable verbose logging\"\n    QUIET = 2, [\"q\", \"quiet\"], \"Suppress all output\", (VERBOSE,)\n    DEBUG = 4, [\"d\", \"debug\"], \"Enable debug mode\", (QUIET,)\n\n    # Different tuple formats supported:\n    DAEMON = 8, \"Run as daemon\"  # Just help text\n    CONFIG = 16, [\"c\", \"config\"], \"Specify config file\"  # No exclusions\n\n# Access help text and aliases\nopt = ServerOptions.VERBOSE\nprint(f\"Help: {opt.help}\")      # Help: Enable verbose logging\nprint(f\"Aliases: {opt.aliases}\")  # Aliases: ['v', 'verbose']\n\n# Conflicts are resolved automatically\nflags = ServerOptions.QUIET | ServerOptions.DEBUG\nprint(flags)  # ServerOptions.DEBUG (DEBUG wins over QUIET)\n</code></pre>"},{"location":"getting-started/#creating-flags-from-integer-values","title":"Creating Flags from Integer Values","text":"<p>You can create flags from raw integer values, and conflicts will be resolved automatically:</p> <pre><code>from highlander import ExFlag\n\nclass NetworkMode(ExFlag):\n    IPV4 = 1\n    IPV6 = 2\n    QUIET = 4\n    VERBOSE = 8, (QUIET,)\n\n# Create from integer with conflicts (1 + 4 + 8 = 13)\n# This represents IPV4 + QUIET + VERBOSE, but QUIET and VERBOSE conflict\nmode = NetworkMode(13)\nprint(mode)  # NetworkMode.IPV4|QUIET (conflict resolved, QUIET wins)\n\n# Check if specific flags are set\nif NetworkMode.IPV4 in mode:\n    print(\"IPv4 is enabled\")  # This will print\n\nif NetworkMode.VERBOSE in mode:\n    print(\"Verbose is enabled\")  # This won't print (QUIET won)\n</code></pre>"},{"location":"getting-started/#adding-exclusions-dynamically","title":"Adding Exclusions Dynamically","text":"<p>You can add exclusions at runtime:</p> <pre><code>from highlander import ExFlag\n\nclass DynamicFlag(ExFlag):\n    A = 1\n    B = 2\n    C = 4\n\n# Add exclusions after class creation\nflag_a = DynamicFlag.A\nflag_a.add_exclusions(DynamicFlag.B, DynamicFlag.C)\n\n# Now A conflicts with B and C\nresult = DynamicFlag.A | DynamicFlag.B\nprint(result)  # DynamicFlag.A (conflicts resolved)\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<p>Now that you've learned the basics, you can:</p> <ol> <li>Read the User Guide - Dive deeper into advanced features and patterns</li> <li>Check out Examples - See real-world usage scenarios</li> <li>Browse the API Reference - Explore all available methods and options</li> </ol>"},{"location":"getting-started/#common-patterns","title":"Common Patterns","text":"<p>Here are some common patterns you'll use with Highlander Enum:</p>"},{"location":"getting-started/#configuration-settings","title":"Configuration Settings","text":"<pre><code>class Config(ExFlag):\n    # Quality levels\n    LOW = 1\n    MEDIUM = 2\n    HIGH = 4\n    ULTRA = 8, (OW, MEDIUM, HIGH)\n\n    # Independent features\n    COMPRESSION = 16\n    ENCRYPTION = 32\n</code></pre>"},{"location":"getting-started/#state-management-coming-soon","title":"State Management (coming soon)","text":"<pre><code>class ConnectionState(ExFlag):\n    DISCONNECTED = 1\n    CONNECTING = 2, (DISCONNECTED,)\n    CONNECTED = 4, (DISCONNECTED, CONNECTING)\n    ERROR = 8, (CONNECTING, CONNECTED)\n</code></pre>"},{"location":"getting-started/#feature-flags","title":"Feature Flags","text":"<pre><code>class Features(OptionsFlag):\n    BETA = 1, [\"b\", \"beta\"], \"Enable beta features\"\n    EXPERIMENTAL = 2, [\"x\", \"exp\"], \"Enable experimental features\", (BETA,)\n    STABLE = 4, [\"s\", \"stable\"], \"Use only stable features\", (BETA, EXPERIMENTAL)\n</code></pre> <p>That's it! You're now ready to use Highlander Enum in your projects. Remember: \"There can be only one!\" \ud83d\udde1\ufe0f</p>"},{"location":"modules/","title":"Core Modules","text":"<p>This page provides auto-generated API documentation for the core Highlander Enum modules.</p>"},{"location":"modules/#highlanderenums","title":"highlander.enums","text":"<p>The main module containing <code>ExFlag</code> and <code>OptionsFlag</code> classes.</p>"},{"location":"modules/#highlander.enums","title":"<code>highlander.enums</code>","text":""},{"location":"modules/#highlander.enums-classes","title":"Classes","text":""},{"location":"modules/#highlander.enums.ExFlag","title":"<code>ExFlag</code>","text":"<p>               Bases: <code>IntFlag</code></p> <p>An IntFlag variation supporting mutually exclusive flags with configurable conflict resolution.</p> <p>ExFlag extends Python's IntFlag to provide \"Highlander\" behavior - when mutually exclusive flags are combined, only one can remain active (there can be only one). The conflict resolution strategy determines which flag wins when conflicts occur.</p> <p>Flags can define mutual exclusions by passing a list of conflicting flags during definition. When conflicting flags are combined using bitwise operations, the configured conflict resolution strategy determines the outcome.</p> <p>Attributes:</p> Name Type Description <code>__exclusives__</code> <code>defaultdict[int, int]</code> <p>Class variable storing bitmasks for mutually exclusive flags.</p> <p>Examples:</p> <p>Basic usage with RHS (default) conflict resolution:     &gt;&gt;&gt; class MyFlag(ExFlag):     ...     FLAG1 = 1     ...     FLAG2 = 2     ...     EXCLUSIVE = 4, [FLAG1, FLAG2]  # Conflicts with FLAG1 and FLAG2     &gt;&gt;&gt; result = MyFlag.FLAG1 | MyFlag.EXCLUSIVE     &gt;&gt;&gt; result == MyFlag.EXCLUSIVE  # RHS wins     True</p> <p>Using different conflict resolution strategies:     &gt;&gt;&gt; class StrictFlag(ExFlag, conflict=\"strict\"):     ...     A = 1     ...     B = 2, [A]     &gt;&gt;&gt; StrictFlag.A | StrictFlag.B  # Raises ValueError     Traceback (most recent call last):     ValueError: ...conflicts with...</p>"},{"location":"modules/#highlander.enums.ExFlag-functions","title":"Functions","text":"<code>__init_subenum__(classdict, **kwargs)</code> \u00b6 <p>Initialize exclusives tracking for each subclass.</p> <p>This method is called by the metaclass to ensure each ExFlag subclass gets its own exclusives dictionary, preventing contamination between different enum classes.</p> <p>Parameters:</p> Name Type Description Default <code>classdict</code> <code>dict[str, Any]</code> <p>Dictionary of class attributes being created.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments (unused).</p> <code>{}</code> Note <p>This is required because init_subclass isn't called until after all enum members and new have been processed.</p> <code>__new__(value, *args)</code> \u00b6 <p>Create new ExFlag enum members with optional exclusion definitions.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>type[ExFlag]</code> <p>The ExFlag class being instantiated.</p> required <code>value</code> <code>int</code> <p>The integer value for this flag.</p> required <code>*args</code> <code>Any</code> <p>Optional arguments where the last argument can be a list of flags that should be mutually exclusive with this flag.</p> <code>()</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new ExFlag instance with the specified value and exclusions.</p> Note <p>If exclusions are provided, they are automatically registered as mutually exclusive with this flag using add_mutual_exclusions.</p> <code>__call__(value)</code> \u00b6 <p>Create an ExFlag instance from an integer value, resolving conflicts.</p> <p>This method is called when creating enum instances from integer values, such as MyFlag(5). It applies conflict resolution by examining each bit in the value and removing conflicting flags according to the exclusion masks.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>type[ExFlag]</code> <p>The ExFlag class.</p> required <code>value</code> <code>int | Any</code> <p>Integer value to convert to an ExFlag instance.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>An ExFlag instance with conflicts resolved according to the</p> <code>Self</code> <p>class's conflict resolution strategy.</p> Note <p>For STRICT mode, _handle_conflict may raise a ValueError if conflicts are detected in the original value.</p> <code>add_mutual_exclusions(mutually_exclusive_values)</code> <code>classmethod</code> \u00b6 <p>Set multiple flags as mutually exclusive with each other.</p> <p>Creates bitmasks stored in the exclusives mapping for fast conflict resolution during bitwise operations. All flags in the sequence will be mutually exclusive with each other - only one from the group can be active at a time.</p> <p>Parameters:</p> Name Type Description Default <code>mutually_exclusive_values</code> <code>Sequence[IntFlag | int]</code> <p>Sequence of flag values (integers or IntFlag instances) that should be mutually exclusive with each other.</p> required Example <p>class MyFlag(ExFlag): ...     A = 1 ...     B = 2 ...     C = 4 MyFlag.add_mutual_exclusions([MyFlag.A, MyFlag.B, MyFlag.C]) result = MyFlag.A | MyFlag.B  # B wins (RHS) result == MyFlag.B True</p> <code>add_exclusions(*exclusive_values)</code> \u00b6 <p>Add flags that are mutually exclusive with this flag instance.</p> <p>This method allows runtime addition of exclusion relationships between this flag and other flags. It creates bidirectional exclusions - this flag will exclude the specified flags, and the specified flags will exclude this flag.</p> <p>Parameters:</p> Name Type Description Default <code>*exclusive_values</code> <code>IntFlag | int</code> <p>Variable number of flags (integers or IntFlag instances) that should be mutually exclusive with this flag.</p> <code>()</code> Example <p>class MyFlag(ExFlag): ...     A = 1 ...     B = 2 ...     C = 4 flag_a = MyFlag.A flag_a.add_exclusions(MyFlag.B, MyFlag.C) result = MyFlag.A | MyFlag.B  # B wins due to RHS resolution result == MyFlag.B True</p> <code>__handle_conflict_rhs__(other)</code> \u00b6 <p>Handle conflicts using RHS (right-hand side) resolution strategy.</p> <p>In RHS mode, when conflicting flags are combined, the right-hand side (newer) value wins. This is the default conflict resolution strategy.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>int</code> <p>Integer value containing the new flag(s) being combined.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Bitmask that removes conflicting bits, allowing the RHS value to win.</p> Example <p>If flag A conflicts with flag B, then A | B results in B.</p> <code>__handle_conflict_lhs__(other)</code> \u00b6 <p>Handle conflicts using LHS (left-hand side) resolution strategy.</p> <p>In LHS mode, when conflicting flags are combined, the left-hand side (existing) value wins and conflicting new values are discarded.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>int</code> <p>Integer value containing the new flag(s) being combined (ignored for conflict resolution, but may be used for validation).</p> required <p>Returns:</p> Type Description <code>int</code> <p>Bitmask that preserves the current (LHS) value and excludes conflicts.</p> Example <p>If flag A conflicts with flag B, then A | B results in A.</p> <code>__handle_conflict_strict__(other)</code> \u00b6 <p>Handle conflicts using STRICT mode - raise ValueError on any conflicts.</p> <p>In STRICT mode, any attempt to combine conflicting flags raises a ValueError with a detailed message describing all conflicts found.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>int</code> <p>Integer value containing the new flag(s) being combined.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Always returns -1 if no conflicts are found (allowing the operation).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any conflicts are detected between the current flags and the new flags being combined.</p> Example <p>If flag A conflicts with flag B, then A | B raises ValueError.</p> <code>__or__(other)</code> \u00b6 <p>Perform bitwise OR operation with conflict resolution.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>int</code> <p>Integer value to combine with this flag.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>New ExFlag instance with the combined value after conflict resolution.</p> <code>__xor__(other)</code> \u00b6 <p>Perform bitwise XOR operation with conflict resolution.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>int</code> <p>Integer value to XOR with this flag.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>New ExFlag instance with the XOR result after conflict resolution.</p>"},{"location":"modules/#highlander.enums.OptionsFlag","title":"<code>OptionsFlag</code>","text":"<p>               Bases: <code>ExFlag</code></p> <p>An ExFlag subclass designed for command-line options with rich member definitions.</p> <p>OptionsFlag extends ExFlag to support command-line option scenarios where flags need aliases, help text, and exclusion relationships. Each flag is defined with a tuple containing the value, optional aliases, help text, and optional exclusions.</p> <p>The class automatically creates properties for accessing help text and aliases, making it suitable for building command-line parsers and help systems.</p> <p>Attributes:</p> Name Type Description <code>help</code> <code>str</code> <p>Property providing read-only access to the flag's help text.</p> <code>aliases</code> <code>list[str]</code> <p>Property providing read-only access to the flag's aliases.</p> <p>Examples:</p> <p>Basic usage with help text and aliases:     &gt;&gt;&gt; class MyOptions(OptionsFlag):     ...     VERBOSE = 1, [\"v\", \"verbose\"], \"Enable verbose output\"     ...     QUIET = 2, [\"q\", \"quiet\"], \"Enable quiet mode\", [VERBOSE]     &gt;&gt;&gt; opt = MyOptions.VERBOSE     &gt;&gt;&gt; opt.help     'Enable verbose output'     &gt;&gt;&gt; opt.aliases     ['v', 'verbose']</p> <p>Tuple format variations:     - (help_str,) - Just help text     - ([aliases], help_str) - Aliases and help text     - ([aliases], help_str, [exclusions]) - Full specification     - (help_str, [exclusions]) - Help and exclusions without aliases</p>"},{"location":"modules/#highlander.enums.OptionsFlag-attributes","title":"Attributes","text":"<code>help</code> <code>property</code> \u00b6 <p>Get the help text for this flag.</p> <p>Returns:</p> Type Description <code>str</code> <p>The help text string provided during flag definition, or empty</p> <code>str</code> <p>string if no help text was provided.</p> <code>aliases</code> <code>property</code> \u00b6 <p>Get the list of aliases for this flag.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of string aliases that can be used to reference this flag.</p> <code>list[str]</code> <p>Returns empty list if no aliases were defined or if the enum</p> <code>list[str]</code> <p>doesn't have a value-to-member mapping.</p> Note <p>Aliases are automatically registered with the enum's internal value2member_map when the flag is created.</p>"},{"location":"modules/#highlander.enums.OptionsFlag-functions","title":"Functions","text":"<code>__init__(*args, **kwargs)</code> \u00b6 <p>Initialize an OptionsFlag instance.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Variable positional arguments passed to parent class.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Variable keyword arguments passed to parent class.</p> <code>{}</code> Note <p>This initializer primarily exists to satisfy type checkers by declaring the _help attribute that gets set during new.</p> <code>__new__(value, *args)</code> \u00b6 <p>Create new OptionsFlag members with help text, aliases, and exclusions.</p> <p>Parses the arguments tuple to extract help text, optional aliases, and optional exclusion relationships. The tuple format is flexible to support various common patterns for defining command-line options.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>type[OptionsFlag]</code> <p>The OptionsFlag class being instantiated.</p> required <code>value</code> <code>int</code> <p>Integer value for this flag.</p> required <code>*args</code> <code>Any</code> <p>Variable arguments in one of these formats: - (help_str,) - Just help text - ([aliases], help_str) - Aliases list and help text - ([aliases], help_str, [exclusions]) - Full specification - (help_str, [exclusions]) - Help text and exclusions</p> <code>()</code> <p>Returns:</p> Type Description <code>Self</code> <p>New OptionsFlag instance with help text, aliases, and exclusions configured.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If no help string is provided or too many arguments are given.</p> Example <p>class MyOptions(OptionsFlag): ...     VERBOSE = 1, [\"v\", \"verbose\"], \"Enable verbose output\" ...     QUIET = 2, \"Enable quiet mode\", [VERBOSE]</p>"},{"location":"modules/#highlandertype","title":"highlander.type","text":"<p>The metaclass and type system supporting Highlander Enum functionality.</p>"},{"location":"modules/#highlander.type","title":"<code>highlander.type</code>","text":""},{"location":"modules/#highlander.type-classes","title":"Classes","text":""},{"location":"modules/#highlander.type.ConflictResolution","title":"<code>ConflictResolution</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Enumeration defining conflict resolution strategies for mutually exclusive flags.</p> <p>This enum defines how Highlander enums should handle conflicts when mutually exclusive flags are combined. Each strategy provides different behavior when incompatible flags are used together in bitwise operations.</p> <p>Attributes:</p> Name Type Description <code>RHS</code> <p>Right-hand side wins. The new value replaces the old value in conflicts.</p> <code>LHS</code> <p>Left-hand side wins. The old value is preserved, new conflicting values are discarded.</p> <code>STRICT</code> <p>Strict mode raises ValueError on any conflicts.</p> <p>Examples:</p> <p>RHS (Right-hand side wins) - default behavior:     &gt;&gt;&gt; from highlander import ExFlag     &gt;&gt;&gt; class F(ExFlag, conflict=\"rhs\"):     ...     FLAG1 = 1     ...     EX_FLAG1 = 2     ...     EX_FLAG2 = 4, [EX_FLAG1]     &gt;&gt;&gt; value = F.EX_FLAG1     &gt;&gt;&gt; value |= F.FLAG1 | F.EX_FLAG2     &gt;&gt;&gt; value == F.FLAG1 | F.EX_FLAG2     True</p> <p>LHS (Left-hand side wins):     &gt;&gt;&gt; class F(ExFlag, conflict=\"lhs\"):     ...     FLAG1 = 1     ...     EX_FLAG1 = 2     ...     EX_FLAG2 = 4, [EX_FLAG1]     &gt;&gt;&gt; value = F.EX_FLAG1     &gt;&gt;&gt; value |= F.FLAG1 | F.EX_FLAG2     &gt;&gt;&gt; value == F.FLAG1 | F.EX_FLAG1     True</p> <p>STRICT (Raises on conflicts):     &gt;&gt;&gt; class F(ExFlag, conflict=\"strict\"):     ...     FLAG1 = 1     ...     EX_FLAG1 = 2     ...     EX_FLAG2 = 4, [EX_FLAG1]     &gt;&gt;&gt; value = F.EX_FLAG1     &gt;&gt;&gt; value |= F.FLAG1 | F.EX_FLAG2     Traceback (most recent call last):     ValueError: F.EX_FLAG1 and F.EX_FLAG2 can't be combined</p>"},{"location":"modules/#highlander.type.EnumPlusType","title":"<code>EnumPlusType</code>","text":"<p>               Bases: <code>EnumType</code></p> <p>Metaclass for creating Enum subclasses with support for advanced features.</p> <p>Metaclass for creating Enum subclasses with support for advanced features such as:     - Better subclassing by supporting super().new.     - Modify subclasses through init_subenum.     - Control member lookups by implementing call.     - Support for flexible conflict resolution policies.     - Preservation of bitwise operators.</p>"},{"location":"modules/#highlander.type.EnumPlusType-functions","title":"Functions","text":"<code>__new__(metacls, cls, bases, classdict, *, conflict_enum_cls=ConflictResolution, conflict=ConflictResolution.RHS, boundary=None, _simple=False, **kwds)</code> \u00b6 <p>Create a new enum class with exclusive flag support.</p> <p>Parameters:</p> Name Type Description Default <code>metacls</code> <code>type[EnumPlusType]</code> <p>The metaclass being used to create the new class.</p> required <code>cls</code> <code>str</code> <p>The name of the enum class being created.</p> required <code>bases</code> <code>tuple[type, ...]</code> <p>Base classes for the new enum class.</p> required <code>classdict</code> <code>dict[str, Any]</code> <p>Dictionary containing the class attributes and methods.</p> required <code>conflict_enum_cls</code> <code>type[Enum]</code> <p>Enum class defining conflict resolution strategies.</p> <code>ConflictResolution</code> <code>conflict</code> <code>Enum | str</code> <p>The conflict resolution strategy to use, either an enum value or string that can be converted to one.</p> <code>RHS</code> <code>boundary</code> <code>Any</code> <p>Boundary handling for flag values (passed to EnumType).</p> <code>None</code> <code>_simple</code> <code>bool</code> <p>Whether this is a simple enum (passed to EnumType).</p> <code>False</code> <code>**kwds</code> <code>Any</code> <p>Additional keyword arguments passed to parent metaclass.</p> <code>{}</code> <p>Returns:</p> Type Description <code>type</code> <p>The newly created enum class with exclusive flag support.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the conflict resolution strategy is invalid or not implemented.</p> <code>restore_new_members(bases)</code> <code>staticmethod</code> \u00b6 <p>Restore original new methods from new_member attributes.</p> <p>This method handles the temporary replacement of new methods during enum creation, storing the original methods for later restoration.</p> <p>Parameters:</p> Name Type Description Default <code>bases</code> <code>tuple[type, ...]</code> <p>Tuple of base classes to examine for new_member attributes.</p> required <p>Returns:</p> Type Description <code>dict[type, Callable[..., Any] | None]</code> <p>Dictionary mapping base classes to their original new methods.</p> <code>dict[type, Callable[..., Any] | None]</code> <p>Values may be None if no original new method existed.</p> <code>restore_news(replaced_new_methods)</code> <code>staticmethod</code> \u00b6 <p>Restore previously saved new methods to their original classes.</p> <p>Parameters:</p> Name Type Description Default <code>replaced_new_methods</code> <code>dict[type, Callable[..., Any] | None]</code> <p>Dictionary mapping classes to their original new methods that should be restored.</p> required"},{"location":"modules/#highlander.type.ValueAliasShim","title":"<code>ValueAliasShim</code>","text":"<p>A mixin-style class to provide add_value_alias to Pythons &lt; 3.13.</p> <p>This is tricky. To set this on the enum class before member creation, I'd have to override EnumDict.setitem.  I could set this as a dunder and then alias the 3.13+ sunder version and just have a different API than standard enums, but I think this is the best approach.  This version of add_value_alias is a slightly lobotomized copy of the Python version, without the ability to handle unhashable values, as that was a mess before 3.13.</p>"},{"location":"modules/#highlander.type-functions","title":"Functions","text":""},{"location":"modules/#highlander.type.traverse_bases","title":"<code>traverse_bases(bases)</code>","text":"<p>Traverse base classes to get an ordered list of the inheritance tree.</p> <p>This function examines the method resolution order (MRO) of all base classes and returns a deduplicated, ordered tuple of all classes in the hierarchy.</p> <p>Parameters:</p> Name Type Description Default <code>bases</code> <code>tuple[type, ...]</code> <p>Tuple of base classes to traverse.</p> required <p>Returns:</p> Type Description <code>type</code> <p>Ordered tuple of all classes in the inheritance hierarchy, excluding</p> <code>...</code> <p>the built-in object class.</p>"},{"location":"modules/#highlander.type.rebind_method","title":"<code>rebind_method(target_name, target_cls, src_method, src_cls=None)</code>","text":"<p>Rebind a method from one class to another with a new name.</p> <p>This function creates a new method on the target class by copying a method from a source class or using a provided method object. The new method maintains the same functionality but can have a different name.</p> <p>Parameters:</p> Name Type Description Default <code>target_name</code> <code>str</code> <p>The name to give the method in the target class.</p> required <code>target_cls</code> <code>type</code> <p>The class to which the method should be bound.</p> required <code>src_method</code> <code>classmethod | staticmethod | Callable[..., Any] | str</code> <p>The source method to copy. Can be: - A classmethod or staticmethod decorator - A callable function - A string name of a method (requires src_cls)</p> required <code>src_cls</code> <code>type | None</code> <p>The source class containing the method (required if src_method is a string).</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If src_method is a string but src_cls is not provided, if the method name is not found in src_cls, or if src_method is not a valid object.</p> <code>TypeError</code> <p>If src_method is not callable or doesn't have the required function attributes.</p>"},{"location":"user-guide/","title":"User Guide","text":"<p>This comprehensive guide covers all features and advanced usage patterns of Highlander Enum.</p>"},{"location":"user-guide/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Core Concepts</li> <li>ExFlag Class</li> <li>OptionsFlag Class</li> <li>Conflict Resolution</li> <li>Advanced Usage</li> <li>Type Safety</li> <li>Best Practices</li> </ol>"},{"location":"user-guide/#core-concepts","title":"Core Concepts","text":""},{"location":"user-guide/#mutually-exclusive-flags","title":"Mutually Exclusive Flags","text":"<p>The fundamental concept behind Highlander Enum is mutual exclusion. When flags are defined as mutually exclusive, only one from the group can be active at any time.</p> <pre><code>from highlander import ExFlag\n\nclass Quality(ExFlag):\n    LOW = 1\n    MEDIUM = 2\n    HIGH = 4\n    ULTRA = 8, (LOW, MEDIUM, HIGH)  # ULTRA conflicts with all others\n</code></pre>"},{"location":"user-guide/#bitmask-implementation","title":"Bitmask Implementation","text":"<p>Under the hood, Highlander Enum uses efficient bitmasks for conflict resolution:</p> <pre><code># When you define exclusions, bitmasks are created automatically\nclass Example(ExFlag):\n    A = 1       # Binary: 0001\n    B = 2, (A,) # Binary: 0010, excludes A (0001)\n    C = 4       # Binary: 0100, no conflicts\n\n# The __exclusives__ mapping stores these relationships\nprint(Example.__exclusives__)  # Shows the internal bitmasks\n</code></pre>"},{"location":"user-guide/#conflict-detection","title":"Conflict Detection","text":"<p>Conflicts are detected during bitwise operations (<code>|</code>, <code>&amp;</code>, <code>^</code>) and flag creation:</p> <pre><code>class Mode(ExFlag):\n    FAST = 1\n    SLOW = 2, (FAST,)\n\n# Conflict detected and resolved during OR operation\nresult = Mode.FAST | Mode.SLOW  # SLOW wins (RHS default)\n\n# Conflict detected and resolved during flag creation\ncombined = Mode(3)  # 3 = FAST(1) + SLOW(2), resolves to FAST\n</code></pre>"},{"location":"user-guide/#exflag-class","title":"ExFlag Class","text":""},{"location":"user-guide/#basic-definition","title":"Basic Definition","text":"<pre><code>from highlander import ExFlag\n\nclass MyFlag(ExFlag):\n    # Simple flags (no conflicts)\n    FEATURE_A = 1\n    FEATURE_B = 2\n\n    # Flag with exclusions\n    EXCLUSIVE = 4\nMyFlag.EXCLUSIVE.add_exclusions(MyFlag.FEATURE_A, MyFlag.FEATURE_B)\n</code></pre>"},{"location":"user-guide/#conflict-resolution-strategies","title":"Conflict Resolution Strategies","text":""},{"location":"user-guide/#rhs-right-hand-side-default","title":"RHS (Right-Hand Side) - Default","text":"<pre><code>class RHSFlag(ExFlag):  # Default behavior\n    A = 1\n    B = 2, (A,)\n\nresult = RHSFlag.A | RHSFlag.B  # B wins\nprint(result)  # RHSFlag.B\n</code></pre>"},{"location":"user-guide/#lhs-left-hand-side","title":"LHS (Left-Hand Side)","text":"<pre><code>from highlander import LHS\n\nclass LHSFlag(ExFlag, conflict=LHS):\n    A = 1\n    B = 2, (A,)\n\nresult = LHSFlag.A | LHSFlag.B  # A wins\nprint(result)  # LHSFlag.A\n</code></pre>"},{"location":"user-guide/#strict-mode","title":"STRICT Mode","text":"<pre><code>from highlander import STRICT\n\nclass StrictFlag(ExFlag, conflict=STRICT):\n    A = 1\n    B = 2, (A,)\n\ntry:\n    result = StrictFlag.A | StrictFlag.B\nexcept ValueError as e:\n    print(f\"Error: {e}\")  # Error: StrictFlag.B conflicts with StrictFlag.A\n</code></pre>"},{"location":"user-guide/#bitwise-operations","title":"Bitwise Operations","text":"<p>All standard bitwise operations work with conflict resolution:</p> <pre><code>class OpFlag(ExFlag):\n    A = 1\n    B = 2, (A,)\n    C = 4\n\n# OR operation with conflict resolution\nresult1 = OpFlag.A | OpFlag.B  # OpFlag.B\n\n# AND operation (no conflict resolution needed)\nresult2 = OpFlag.A &amp; OpFlag.C  # OpFlag(0) if no common bits\n\n# XOR operation with conflict resolution\nresult3 = OpFlag.A ^ OpFlag.B  # OpFlag.B\n\n# Reverse operations also work\nresult4 = 1 | OpFlag.B  # OpFlag.B\n</code></pre>"},{"location":"user-guide/#dynamic-exclusions","title":"Dynamic Exclusions","text":"<p>Add exclusions at runtime using the <code>add_exclusions</code> method:</p> <pre><code>class DynamicFlag(ExFlag):\n    X = 1\n    Y = 2\n    Z = 4\n\n# Add exclusions after class creation\nflag_x = DynamicFlag.X\nflag_x.add_exclusions(DynamicFlag.Y, DynamicFlag.Z)\n\n# Now X conflicts with Y and Z\nresult = DynamicFlag.X | DynamicFlag.Y\nprint(result)  # DynamicFlag.X (conflicts resolved)\n</code></pre>"},{"location":"user-guide/#class-level-exclusions","title":"Class-Level Exclusions","text":"<p>Use <code>add_mutual_exclusions</code> to set up complex relationships:</p> <pre><code>class GroupFlag(ExFlag):\n    A = 1\n    B = 2\n    C = 4\n    D = 8\n\n# Make A, B, C mutually exclusive (D remains independent)\nGroupFlag.add_mutual_exclusions([GroupFlag.A, GroupFlag.B, GroupFlag.C])\n\nresult = GroupFlag.A | GroupFlag.B | GroupFlag.D\nprint(result)  # GroupFlag.B|D (B wins over A, D is independent)\n</code></pre>"},{"location":"user-guide/#optionsflag-class","title":"OptionsFlag Class","text":"<p><code>OptionsFlag</code> extends <code>ExFlag</code> with features specifically designed for command-line options and configuration systems.</p>"},{"location":"user-guide/#tuple-formats","title":"Tuple Formats","text":"<p><code>OptionsFlag</code> supports multiple tuple formats for maximum flexibility:</p> <pre><code>from highlander import OptionsFlag\n\nclass CLIOptions(OptionsFlag):\n    # Format 1: (value, help_string)\n    SIMPLE = 1, \"Simple option with help text\"\n\n    # Format 2: (value, [aliases], help_string)\n    WITH_ALIASES = 2, [\"a\", \"alias\"], \"Option with aliases\"\n\n    # Format 3: (value, [aliases], help_string, [exclusions])\n    FULL = 4, [\"f\", \"full\"], \"Full specification\", (WITH_ALIASES,)\n\n    # Format 4: (value, help_string, [exclusions])\n    HELP_EXCL = 8, \"Help with exclusions\", (SIMPLE,)\n\n    # Format 5: (value, [], help_string) - empty aliases\n    EMPTY_ALIASES = 16, [], \"Option with empty aliases list\"\n</code></pre>"},{"location":"user-guide/#accessing-metadata","title":"Accessing Metadata","text":"<pre><code>class ServerOpts(OptionsFlag):\n    VERBOSE = 1, [\"v\", \"verbose\"], \"Enable verbose output\"\n    QUIET = 2, [\"q\", \"quiet\"], \"Suppress output\", (VERBOSE,)\n    DEBUG = 4, [\"d\", \"debug\"], \"Enable debug mode\"\n\n# Access help text\nprint(ServerOpts.VERBOSE.help)    # \"Enable verbose output\"\nprint(ServerOpts.QUIET.help)      # \"Suppress output\"\n\n# Access aliases\nprint(ServerOpts.VERBOSE.aliases) # ['v', 'verbose']\nprint(ServerOpts.DEBUG.aliases)   # []\n\n# Aliases are automatically registered for lookups\nverbose_flag = ServerOpts._value2member_map_['verbose']\nprint(verbose_flag == ServerOpts.VERBOSE)  # True\n</code></pre>"},{"location":"user-guide/#building-cli-parsers","title":"Building CLI Parsers","text":"<p><code>OptionsFlag</code> is perfect for building command-line parsers:</p> <pre><code>import argparse\nfrom highlander import OptionsFlag\n\nclass ProcessorOptions(OptionsFlag):\n    FAST = 1, [\"f\", \"fast\"], \"Fast processing mode\"\n    ACCURATE = 2, [\"a\", \"accurate\"], \"Accurate processing mode\", (FAST,)\n    VERBOSE = 4, [\"v\", \"verbose\"], \"Verbose output\"\n    QUIET = 8, [\"q\", \"quiet\"], \"Quiet mode\", (VERBOSE,)\n\ndef create_parser():\n    parser = argparse.ArgumentParser()\n\n    # Add options based on flag definitions\n    for option in ProcessorOptions:\n        primary_name = f\"--{option.name.lower().replace('_', '-')}\"\n        aliases = [f\"--{alias}\" for alias in option.aliases]\n\n        parser.add_argument(\n            primary_name, *aliases,\n            action='store_true',\n            help=option.help\n        )\n\n    return parser\n\n# Usage\nparser = create_parser()\nargs = parser.parse_args(['--fast', '--verbose'])\n\n# Convert args to flags\nflags = ProcessorOptions(0)\nif args.fast: flags |= ProcessorOptions.FAST\nif args.accurate: flags |= ProcessorOptions.ACCURATE\nif args.verbose: flags |= ProcessorOptions.VERBOSE\nif args.quiet: flags |= ProcessorOptions.QUIET\n\nprint(flags)  # ProcessorOptions.FAST|VERBOSE\n</code></pre>"},{"location":"user-guide/#conflict-resolution","title":"Conflict Resolution","text":""},{"location":"user-guide/#understanding-resolution-strategies","title":"Understanding Resolution Strategies","text":"<p>Each strategy handles conflicts differently when mutually exclusive flags are combined:</p>"},{"location":"user-guide/#rhs-strategy-practical-example","title":"RHS Strategy - Practical Example","text":"<pre><code>from highlander import ExFlag\n\nclass LogLevel(ExFlag):  # Default: RHS\n    ERROR = 1\n    WARN = 2\n    INFO = 4\n    DEBUG = 8, (ERROR, WARN, INFO)\n\n# Building up configuration step by step\nconfig = LogLevel.ERROR\nprint(f\"Initial: {config}\")        # Initial: LogLevel.ERROR\n\nconfig |= LogLevel.WARN\nprint(f\"After WARN: {config}\")     # After WARN: LogLevel.WARN (WARN wins)\n\nconfig |= LogLevel.DEBUG\nprint(f\"After DEBUG: {config}\")    # After DEBUG: LogLevel.DEBUG (DEBUG wins)\n</code></pre>"},{"location":"user-guide/#lhs-strategy-preserving-original-values","title":"LHS Strategy - Preserving Original Values","text":"<pre><code>from highlander import ExFlag, LHS\n\nclass SecureMode(ExFlag, conflict=LHS):\n    BASIC = 1\n    ENHANCED = 2\n    MAXIMUM = 4, (BASIC, ENHANCED)\n\n# Once set, original value is preserved\nsecurity = SecureMode.MAXIMUM\nprint(f\"Initial: {security}\")      # Initial: SecureMode.MAXIMUM\n\nsecurity |= SecureMode.BASIC\nprint(f\"After BASIC: {security}\")  # After BASIC: SecureMode.MAXIMUM (preserved)\n\nsecurity |= SecureMode.ENHANCED\nprint(f\"After ENHANCED: {security}\")  # After ENHANCED: SecureMode.MAXIMUM (preserved)\n</code></pre>"},{"location":"user-guide/#strict-strategy-fail-fast-validation","title":"STRICT Strategy - Fail-Fast Validation","text":"<pre><code>from highlander import ExFlag, STRICT\n\nclass ValidatedFlag(ExFlag, conflict=STRICT):\n    OPTION_A = 1\n    OPTION_B = 2, (OPTION_A,)\n    OPTION_C = 4\n\ndef safe_combine(flag1, flag2):\n    try:\n        return flag1 | flag2\n    except ValueError as e:\n        print(f\"Cannot combine {flag1} and {flag2}: {e}\")\n        return None\n\nresult1 = safe_combine(ValidatedFlag.OPTION_A, ValidatedFlag.OPTION_C)\nprint(result1)  # ValidatedFlag.OPTION_A|OPTION_C (no conflict)\n\nresult2 = safe_combine(ValidatedFlag.OPTION_A, ValidatedFlag.OPTION_B)\nprint(result2)  # None (conflict detected and handled)\n</code></pre>"},{"location":"user-guide/#conflict-resolution-in-complex-scenarios","title":"Conflict Resolution in Complex Scenarios","text":"<pre><code>from highlander import ExFlag\n\nclass ComplexFlag(ExFlag):\n    # Group 1: Colors\n    RED = 1\n    GREEN = 2\n    BLUE = 4, (RED, GREEN)\n\n    # Group 2: Sizes\n    SMALL = 8\n    MEDIUM = 16\n    LARGE = 32, (SMALL, MEDIUM)\n\n    # Independent\n    ANIMATED = 64\n\n# Multiple conflicts resolved simultaneously\ncomplex_value = ComplexFlag.RED | ComplexFlag.GREEN | ComplexFlag.SMALL | ComplexFlag.LARGE | ComplexFlag.ANIMATED\n\n# Results in: GREEN (wins over RED) + LARGE (wins over SMALL) + ANIMATED (no conflict)\nprint(complex_value)  # ComplexFlag.ANIMATED|GREEN|LARGE\n</code></pre>"},{"location":"user-guide/#advanced-usage","title":"Advanced Usage","text":""},{"location":"user-guide/#inheritance-and-base-classes","title":"Inheritance and Base Classes","text":"<pre><code>from highlander import ExFlag\n\nclass BaseFlag(ExFlag):\n    FEATURE_A = 1\n    FEATURE_B = 2, (FEATURE_A,)\n\nclass ExtendedFlag(BaseFlag):\n    FEATURE_C = 4\n    FEATURE_D = 8, (FEATURE_B, FEATURE_C)  # Can reference parent flags\n\n# All exclusions work across the inheritance hierarchy\nresult = ExtendedFlag.FEATURE_A | ExtendedFlag.FEATURE_D\nprint(result)  # ExtendedFlag.FEATURE_D (wins over FEATURE_A through FEATURE_B)\n</code></pre>"},{"location":"user-guide/#auto-values-with-exclusions","title":"Auto Values with Exclusions","text":"<pre><code>from enum import auto\nfrom highlander import OptionsFlag\n\nclass AutoOptions(OptionsFlag):\n    VERBOSE = auto(), [\"v\"], \"Verbose output\"\n    QUIET = auto(), [\"q\"], \"Quiet mode\", (VERBOSE,)\n    DEBUG = auto(), [\"d\"], \"Debug mode\", (QUIET,)\n\n    # auto() generates power-of-2 values automatically for flags\n    FEATURE_X = auto(), \"Another feature\"\n\n# Check the generated values\nfor opt in AutoOptions:\n    print(f\"{opt.name}: {opt.value} (binary: {bin(opt.value)})\")\n</code></pre>"},{"location":"user-guide/#custom-conflict-handlers","title":"Custom Conflict Handlers","text":"<p>For advanced use cases, you can examine the internal conflict handling:</p> <pre><code>class CustomFlag(ExFlag):\n    A = 1\n    B = 2, (A,)\n    C = 4\n\n# Examine exclusion masks\nprint(f\"A exclusions: {bin(CustomFlag.__exclusives__[1])}\")\nprint(f\"B exclusions: {bin(CustomFlag.__exclusives__[2])}\")\nprint(f\"C exclusions: {bin(CustomFlag.__exclusives__[4])}\")\n\n# The exclusion mask for A excludes B (value 2)\n# So A's mask will be ~2 which allows everything except bit 1\n</code></pre>"},{"location":"user-guide/#working-with-raw-integers","title":"Working with Raw Integers","text":"<pre><code>class IntFlag(ExFlag):\n    LOW = 1\n    HIGH = 2, (LOW,)\n    EXTRA = 4\n\n# Create from raw integers with automatic conflict resolution\nflag1 = IntFlag(1 | 2)  # LOW + HIGH conflict\nprint(flag1)  # IntFlag.LOW (conflict resolved)\n\nflag2 = IntFlag(1 | 4)  # LOW + EXTRA no conflict\nprint(flag2)  # IntFlag.LOW|EXTRA\n\n# Check membership\nif IntFlag.LOW in flag2:\n    print(\"LOW is present\")\n\n# Get raw integer value\nraw_value = int(flag2)\nprint(f\"Raw value: {raw_value}\")  # Raw value: 5\n</code></pre>"},{"location":"user-guide/#type-safety","title":"Type Safety","text":""},{"location":"user-guide/#type-hints","title":"Type Hints","text":"<p>Highlander Enum provides full type safety:</p> <pre><code>from typing import Union\nfrom highlander import ExFlag\n\nclass TypedFlag(ExFlag):\n    OPTION_A = 1\n    OPTION_B = 2, (OPTION_A,)\n\ndef process_flag(flag: TypedFlag) -&gt; str:\n    \"\"\"Process a flag with full type safety.\"\"\"\n    if flag &amp; TypedFlag.OPTION_A:\n        return \"Processing A\"\n    elif flag &amp; TypedFlag.OPTION_B:\n        return \"Processing B\"\n    else:\n        return \"No options\"\n\n# Type checkers will validate these calls\nresult1 = process_flag(TypedFlag.OPTION_A)         # \u2713 Valid\nresult2 = process_flag(TypedFlag.OPTION_A | TypedFlag.OPTION_B)  # \u2713 Valid\n\n# This would cause a type error:\n# result3 = process_flag(\"invalid\")  # \u2717 Type error\n</code></pre>"},{"location":"user-guide/#generic-patterns","title":"Generic Patterns","text":"<pre><code>from typing import TypeVar, Generic\nfrom highlander import ExFlag\n\nT = TypeVar('T', bound=ExFlag)\n\nclass ConfigManager(Generic[T]):\n    def __init__(self, flag_class: type[T]) -&gt; None:\n        self.flag_class = flag_class\n        self.current_flags: T = flag_class(0)\n\n    def set_flag(self, flag: T) -&gt; None:\n        self.current_flags |= flag\n\n    def get_flags(self) -&gt; T:\n        return self.current_flags\n\n# Usage with type safety\nclass MyFlags(ExFlag):\n    A = 1\n    B = 2, (A,)\n\nmanager = ConfigManager(MyFlags)\nmanager.set_flag(MyFlags.A)  # Type safe\n</code></pre>"},{"location":"user-guide/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/#1-clear-naming-conventions","title":"1. Clear Naming Conventions","text":"<pre><code># Good: Clear, descriptive names\nclass LoggingMode(ExFlag):\n    ERROR_ONLY = 1\n    INCLUDE_WARNINGS = 2\n    INCLUDE_INFO = 4\n    FULL_DEBUG = 8, (ERROR_ONLY, INCLUDE_WARNINGS, INCLUDE_INFO)\n\n# Avoid: Unclear abbreviations\nclass BadFlag(ExFlag):\n    E = 1\n    W = 2\n    I = 4\n    D = 8, (E, W, I)\n</code></pre>"},{"location":"user-guide/#2-logical-grouping","title":"2. Logical Grouping","text":"<pre><code># Good: Group related exclusions logically\nclass UISettings(ExFlag):\n    # Theme group\n    LIGHT = 1\n    DARK = 2\n    HIGH_CONTRAST = 4, (LIGHT, DARK)\n\n    # Size group\n    SMALL = 8\n    LARGE = 16, (SMALL,)\n\n    # Independent features\n    ANIMATIONS = 32\n    TOOLTIPS = 64\n\n# Avoid: Mixed unrelated exclusions\nclass BadSettings(ExFlag):\n    LIGHT = 1\n    SMALL = 2, (LIGHT,)  # Theme and size shouldn't conflict\n    ANIMATIONS = 4, (LIGHT,)  # Animations and theme shouldn't conflict\n</code></pre>"},{"location":"user-guide/#3-document-complex-relationships","title":"3. Document Complex Relationships","text":"<pre><code>class ComplexSystem(ExFlag):\n    \"\"\"System configuration flags with multiple exclusion groups.\n\n    Exclusion Groups:\n    - Performance: FAST, BALANCED, THOROUGH\n    - Verbosity: QUIET, NORMAL, VERBOSE\n    - Output: JSON, XML, CSV\n    \"\"\"\n\n    # Performance group (mutually exclusive)\n    FAST = 1\n    BALANCED = 2\n    THOROUGH = 4, (FAST, BALANCED)\n\n    # Verbosity group (mutually exclusive)\n    QUIET = 8\n    NORMAL = 16\n    VERBOSE = 32, (QUIET, NORMAL)\n\n    # Output format group (mutually exclusive)\n    JSON = 64\n    XML = 128\n    CSV = 256, (JSON, XML)\n</code></pre>"},{"location":"user-guide/#4-use-appropriate-conflict-resolution","title":"4. Use Appropriate Conflict Resolution","text":"<pre><code># Use RHS for progressive configuration\nclass ProgressiveConfig(ExFlag):  # Default RHS\n    BASIC = 1\n    ENHANCED = 2\n    PREMIUM = 4, (BASIC, ENHANCED)\n\n# Use LHS for security/stability\nclass SecurityLevel(ExFlag, conflict=LHS):\n    LOW = 1\n    MEDIUM = 2\n    HIGH = 4, (LOW, MEDIUM)\n\n# Use STRICT for validation\nclass ValidatedOptions(ExFlag, conflict=STRICT):\n    DEVELOPMENT = 1\n    PRODUCTION = 2, (DEVELOPMENT,)\n</code></pre>"},{"location":"user-guide/#5-test-edge-cases","title":"5. Test Edge Cases","text":"<pre><code>import pytest\nfrom highlander import ExFlag\n\nclass TestFlag(ExFlag):\n    A = 1\n    B = 2, (A,)\n\ndef test_conflict_resolution():\n    \"\"\"Test that conflicts are resolved correctly.\"\"\"\n    result = TestFlag.A | TestFlag.B\n    assert result == TestFlag.B  # RHS wins\n\ndef test_integer_creation():\n    \"\"\"Test creating flags from integers.\"\"\"\n    flag = TestFlag(3)  # A + B\n    assert flag == TestFlag.A  # Conflict resolved\n\ndef test_no_conflict():\n    \"\"\"Test non-conflicting combinations.\"\"\"\n    # Add non-conflicting flag for testing\n    class ExtendedFlag(TestFlag):\n        C = 4\n\n    result = ExtendedFlag.A | ExtendedFlag.C\n    assert result.value == 5  # Should combine normally\n</code></pre> <p>This completes the comprehensive User Guide. For specific implementation examples, see the Examples section, or check the API Reference for detailed method documentation.</p>"}]}